import {
  R,
  he
} from "./chunk-YEIPR2AD.js";
import "./chunk-6HNT5MVJ.js";
import "./chunk-ZN5QT2LU.js";
import {
  Fragment,
  Transition,
  cloneVNode,
  computed,
  createCommentVNode,
  getCurrentScope,
  h,
  inject,
  mergeProps,
  nextTick,
  onBeforeUnmount,
  onMounted,
  onScopeDispose,
  provide,
  ref,
  shallowReadonly,
  shallowRef,
  toRef,
  unref,
  watch,
  watchEffect
} from "./chunk-KYRVEH3J.js";
import {
  __objRest,
  __spreadProps,
  __spreadValues,
  init_define_process_env
} from "./chunk-PLO4ZEQ3.js";

// dep:@headlessui-float_vue
init_define_process_env();

// node_modules/@headlessui-float/vue/dist/headlessui-float.mjs
init_define_process_env();

// node_modules/@floating-ui/vue/dist/floating-ui.vue.esm.js
init_define_process_env();

// node_modules/@floating-ui/dom/dist/floating-ui.dom.esm.js
init_define_process_env();

// node_modules/@floating-ui/core/dist/floating-ui.core.esm.js
init_define_process_env();
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getLengthFromAxis(axis) {
  return axis === "y" ? "height" : "width";
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "x" : "y";
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  const commonAlign = reference[length] / 2 - floating[length] / 2;
  const side = getSide(placement);
  const isVertical = mainAxis === "x";
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  if (true) {
    if (platform2 == null) {
      console.error(["Floating UI: `platform` property was not passed to config. If you", "want to use Floating UI on the web, install @floating-ui/dom", "instead of the /core package. Otherwise, you can create your own", "`platform`: https://floating-ui.com/docs/platform"].join(" "));
    }
    if (validMiddleware.filter((_ref) => {
      let {
        name
      } = _ref;
      return name === "autoPlacement" || name === "flip";
    }).length > 1) {
      throw new Error(["Floating UI: duplicate `flip` and/or `autoPlacement` middleware", "detected. This will lead to an infinite loop. Ensure only one of", "either has been passed to the `middleware` array."].join(" "));
    }
    if (!reference || !floating) {
      console.error(["Floating UI: The reference and/or floating element was not defined", "when `computePosition()` was called. Ensure that both elements have", "been created and can be measured."].join(" "));
    }
  }
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = __spreadProps(__spreadValues({}, middlewareData), {
      [name]: __spreadValues(__spreadValues({}, middlewareData[name]), data)
    });
    if (true) {
      if (resetCount > 50) {
        console.warn(["Floating UI: The middleware lifecycle appears to be running in an", "infinite loop. This is usually caused by a `reset` continually", "being returned without a break condition."].join(" "));
      }
    }
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
      continue;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
function expandPaddingObject(padding) {
  return __spreadValues({
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }, padding);
}
function getSideObjectFromPadding(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  return __spreadProps(__spreadValues({}, rect), {
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = options;
  const paddingObject = getSideObjectFromPadding(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? __spreadProps(__spreadValues({}, rects.floating), {
    x,
    y
  }) : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect,
    offsetParent,
    strategy
  }) : rect);
  if (true)
    ;
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var min = Math.min;
var max = Math.max;
function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      element,
      padding = 0
    } = options || {};
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements
    } = state;
    if (element == null) {
      if (true) {
        console.warn("Floating UI: No `element` was passed to the `arrow` middleware.");
      }
      return {};
    }
    const paddingObject = getSideObjectFromPadding(padding);
    const coords = {
      x,
      y
    };
    const axis = getMainAxisFromPlacement(placement);
    const length = getLengthFromAxis(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const min3 = paddingObject[minProp];
    const max3 = clientSize - arrowDimensions[length] - paddingObject[maxProp];
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = within(min3, center, max3);
    const shouldAddOffset = getAlignment(placement) != null && center != offset2 && rects.reference[length] / 2 - (center < min3 ? paddingObject[minProp] : paddingObject[maxProp]) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min3 ? min3 - center : max3 - center : 0;
    return {
      [axis]: coords[axis] - alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2
      }
    };
  }
});
var sides = ["top", "right", "bottom", "left"];
var allPlacements = sides.reduce((acc, side) => acc.concat(side, side + "-start", side + "-end"), []);
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  let mainAlignmentSide = mainAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return {
    main: mainAlignmentSide,
    cross: getOppositePlacement(mainAlignmentSide)
  };
}
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getPlacementList(alignment, autoAlignment, allowedPlacements) {
  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter((placement) => getAlignment(placement) === alignment), ...allowedPlacements.filter((placement) => getAlignment(placement) !== alignment)] : allowedPlacements.filter((placement) => getSide(placement) === placement);
  return allowedPlacementsSortedByAlignment.filter((placement) => {
    if (alignment) {
      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
    }
    return true;
  });
}
var autoPlacement = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "autoPlacement",
    options,
    async fn(state) {
      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;
      const {
        rects,
        middlewareData,
        placement,
        platform: platform2,
        elements
      } = state;
      const _a = options, {
        crossAxis = false,
        alignment,
        allowedPlacements = allPlacements,
        autoAlignment = true
      } = _a, detectOverflowOptions = __objRest(_a, [
        "crossAxis",
        "alignment",
        "allowedPlacements",
        "autoAlignment"
      ]);
      const placements = alignment !== void 0 || allowedPlacements === allPlacements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;
      const currentPlacement = placements[currentIndex];
      if (currentPlacement == null) {
        return {};
      }
      const {
        main,
        cross
      } = getAlignmentSides(currentPlacement, rects, await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)));
      if (placement !== currentPlacement) {
        return {
          reset: {
            placement: placements[0]
          }
        };
      }
      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[main], overflow[cross]];
      const allOverflows = [...((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || [], {
        placement: currentPlacement,
        overflows: currentOverflows
      }];
      const nextPlacement = placements[currentIndex + 1];
      if (nextPlacement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: nextPlacement
          }
        };
      }
      const placementsSortedByMostSpace = allOverflows.map((d) => {
        const alignment2 = getAlignment(d.placement);
        return [d.placement, alignment2 && crossAxis ? d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) : d.overflows[0], d.overflows];
      }).sort((a, b) => a[1] - b[1]);
      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter((d) => d[2].slice(0, getAlignment(d[0]) ? 2 : 3).every((v) => v <= 0));
      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];
      if (resetPlacement !== placement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: resetPlacement
          }
        };
      }
      return {};
    }
  };
};
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const _a = options, {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true
      } = _a, detectOverflowOptions = __objRest(_a, [
        "mainAxis",
        "crossAxis",
        "fallbackPlacements",
        "fallbackStrategy",
        "fallbackAxisSideDirection",
        "flipAlignment"
      ]);
      const side = getSide(placement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const {
          main,
          cross
        } = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[main], overflow[cross]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$map$so;
              const placement2 = (_overflowsData$map$so = overflowsData.map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
var hide = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const _a = options, {
        strategy = "referenceHidden"
      } = _a, detectOverflowOptions = __objRest(_a, [
        "strategy"
      ]);
      const {
        rects
      } = state;
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, __spreadProps(__spreadValues({}, detectOverflowOptions), {
            elementContext: "reference"
          }));
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, __spreadProps(__spreadValues({}, detectOverflowOptions), {
            altBoundary: true
          }));
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords(state, value) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getMainAxisFromPlacement(placement) === "x";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = typeof value === "function" ? value(state) : value;
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : __spreadValues({
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null
  }, rawValue);
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(value) {
  if (value === void 0) {
    value = 0;
  }
  return {
    name: "offset",
    options: value,
    async fn(state) {
      const {
        x,
        y
      } = state;
      const diffCoords = await convertValueToCoords(state, value);
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: diffCoords
      };
    }
  };
};
function getCrossAxis(axis) {
  return axis === "x" ? "y" : "x";
}
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const _a = options, {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        }
      } = _a, detectOverflowOptions = __objRest(_a, [
        "mainAxis",
        "crossAxis",
        "limiter"
      ]);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const mainAxis = getMainAxisFromPlacement(getSide(placement));
      const crossAxis = getCrossAxis(mainAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min3 = mainAxisCoord + overflow[minSide];
        const max3 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = within(min3, mainAxisCoord, max3);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min3 = crossAxisCoord + overflow[minSide];
        const max3 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = within(min3, crossAxisCoord, max3);
      }
      const limitedCoords = limiter.fn(__spreadProps(__spreadValues({}, state), {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      }));
      return __spreadProps(__spreadValues({}, limitedCoords), {
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y
        }
      });
    }
  };
};

// node_modules/@floating-ui/dom/dist/floating-ui.dom.esm.js
function getWindow(node) {
  var _node$ownerDocument;
  return ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function isNode(value) {
  return value instanceof getWindow(value).Node;
}
function getNodeName(node) {
  return isNode(node) ? (node.nodeName || "").toLowerCase() : "";
}
var uaString;
function getUAString() {
  if (uaString) {
    return uaString;
  }
  const uaData = navigator.userAgentData;
  if (uaData && Array.isArray(uaData.brands)) {
    uaString = uaData.brands.map((item) => item.brand + "/" + item.version).join(" ");
    return uaString;
  }
  return navigator.userAgent;
}
function isHTMLElement(value) {
  return value instanceof getWindow(value).HTMLElement;
}
function isElement(value) {
  return value instanceof getWindow(value).Element;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  const OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isContainingBlock(element) {
  const isFirefox = /firefox/i.test(getUAString());
  const css = getComputedStyle$1(element);
  const backdropFilter = css.backdropFilter || css.WebkitBackdropFilter;
  return css.transform !== "none" || css.perspective !== "none" || (backdropFilter ? backdropFilter !== "none" : false) || isFirefox && css.willChange === "filter" || isFirefox && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective"].some((value) => css.willChange.includes(value)) || ["paint", "layout", "strict", "content"].some((value) => {
    const contain = css.contain;
    return contain != null ? contain.includes(value) : false;
  });
}
function isClientRectVisualViewportBased() {
  return /^((?!chrome|android).)*safari/i.test(getUAString());
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
var min2 = Math.min;
var max2 = Math.max;
var round = Math.round;
function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width);
  let height = parseFloat(css.height);
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    fallback: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
var FALLBACK_SCALE = {
  x: 1,
  y: 1
};
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return FALLBACK_SCALE;
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    fallback
  } = getCssDimensions(domElement);
  let x = (fallback ? round(rect.width) : rect.width) / width;
  let y = (fallback ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  var _win$visualViewport, _win$visualViewport2;
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = FALLBACK_SCALE;
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const win = domElement ? getWindow(domElement) : window;
  const addVisualOffsets = isClientRectVisualViewportBased() && isFixedStrategy;
  let x = (clientRect.left + (addVisualOffsets ? ((_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) || 0 : 0)) / scale.x;
  let y = (clientRect.top + (addVisualOffsets ? ((_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) || 0 : 0)) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win2 = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentIFrame = win2.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== win2) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle(currentIFrame);
      iframeRect.x += (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      iframeRect.y += (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += iframeRect.x;
      y += iframeRect.y;
      currentIFrame = getWindow(currentIFrame).frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getDocumentElement(node) {
  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  if (offsetParent === documentElement) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = {
    x: 1,
    y: 1
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max2(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max2(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x += max2(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = node.assignedSlot || node.parentNode || isShadowRoot(node) && node.host || getDocumentElement(node);
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return parentNode.ownerDocument.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list) {
  var _node$ownerDocument;
  if (list === void 0) {
    list = [];
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor));
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isClientRectVisualViewportBased();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : {
    x: 1,
    y: 1
  };
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const mutableRect = __spreadValues({}, clippingAncestor);
    if (isClientRectVisualViewportBased()) {
      var _win$visualViewport, _win$visualViewport2;
      const win = getWindow(element);
      mutableRect.x -= ((_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) || 0;
      mutableRect.y -= ((_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) || 0;
    }
    rect = mutableRect;
  }
  return rectToClientRect(rect);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const containingBlock = isContainingBlock(currentNode);
    const shouldIgnoreCurrentNode = computedStyle.position === "fixed";
    if (shouldIgnoreCurrentNode) {
      currentContainingBlockComputedStyle = null;
    } else {
      const shouldDropCurrentNode = elementIsFixed ? !containingBlock && !currentContainingBlockComputedStyle : !containingBlock && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position);
      if (shouldDropCurrentNode) {
        result = result.filter((ancestor) => ancestor !== currentNode);
      } else {
        currentContainingBlockComputedStyle = computedStyle;
      }
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max2(rect.top, accRect.top);
    accRect.right = min2(rect.right, accRect.right);
    accRect.bottom = min2(rect.bottom, accRect.bottom);
    accRect.left = max2(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  return getCssDimensions(element);
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = getParentNode(currentNode);
    }
  }
  return null;
}
function getOffsetParent(element, polyfill) {
  const window2 = getWindow(element);
  if (!isHTMLElement(element)) {
    return window2;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const rect = getBoundingClientRect(element, true, strategy === "fixed", offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
var platform = {
  getClippingRect,
  convertOffsetParentRelativeRectToViewportRelativeRect,
  isElement,
  getDimensions,
  getOffsetParent,
  getDocumentElement,
  getScale,
  async getElementRects(_ref) {
    let {
      reference,
      floating,
      strategy
    } = _ref;
    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
    const getDimensionsFn = this.getDimensions;
    return {
      reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),
      floating: __spreadValues({
        x: 0,
        y: 0
      }, await getDimensionsFn(floating))
    };
  },
  getClientRects: (element) => Array.from(element.getClientRects()),
  isRTL: (element) => getComputedStyle$1(element).direction === "rtl"
};
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll: _ancestorScroll = true,
    ancestorResize = true,
    elementResize = true,
    animationFrame = false
  } = options;
  const ancestorScroll = _ancestorScroll && !animationFrame;
  const ancestors = ancestorScroll || ancestorResize ? [...isElement(reference) ? getOverflowAncestors(reference) : reference.contextElement ? getOverflowAncestors(reference.contextElement) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  let observer = null;
  if (elementResize) {
    let initialUpdate = true;
    observer = new ResizeObserver(() => {
      if (!initialUpdate) {
        update();
      }
      initialUpdate = false;
    });
    isElement(reference) && !animationFrame && observer.observe(reference);
    if (!isElement(reference) && reference.contextElement && !animationFrame) {
      observer.observe(reference.contextElement);
    }
    observer.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _observer;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    (_observer = observer) == null ? void 0 : _observer.disconnect();
    observer = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = __spreadValues({
    platform
  }, options);
  const platformWithCache = __spreadProps(__spreadValues({}, mergedOptions.platform), {
    _c: cache
  });
  return computePosition(reference, floating, __spreadProps(__spreadValues({}, mergedOptions), {
    platform: platformWithCache
  }));
};

// node_modules/@floating-ui/vue/dist/floating-ui.vue.esm.js
function unwrapElement2(element) {
  var _$el;
  return (_$el = element == null ? void 0 : element.$el) != null ? _$el : element;
}
function arrow2(options) {
  return {
    name: "arrow",
    options,
    fn(args) {
      const element = unwrapElement2(unref(options.element));
      if (element == null) {
        return {};
      }
      return arrow({
        element,
        padding: options.padding
      }).fn(args);
    }
  };
}
function useFloating(reference, floating, options) {
  if (options === void 0) {
    options = {};
  }
  const whileElementsMountedOption = options.whileElementsMounted;
  const openOption = computed(() => {
    var _unref;
    return (_unref = unref(options.open)) != null ? _unref : true;
  });
  const middlewareOption = computed(() => unref(options.middleware));
  const placementOption = computed(() => {
    var _unref2;
    return (_unref2 = unref(options.placement)) != null ? _unref2 : "bottom";
  });
  const strategyOption = computed(() => {
    var _unref3;
    return (_unref3 = unref(options.strategy)) != null ? _unref3 : "absolute";
  });
  const referenceElement = computed(() => unwrapElement2(reference.value));
  const floatingElement = computed(() => unwrapElement2(floating.value));
  const x = ref(null);
  const y = ref(null);
  const strategy = ref(strategyOption.value);
  const placement = ref(placementOption.value);
  const middlewareData = shallowRef({});
  const isPositioned = ref(false);
  let whileElementsMountedCleanup;
  function update() {
    if (referenceElement.value == null || floatingElement.value == null) {
      return;
    }
    computePosition2(referenceElement.value, floatingElement.value, {
      middleware: middlewareOption.value,
      placement: placementOption.value,
      strategy: strategyOption.value
    }).then((position) => {
      x.value = position.x;
      y.value = position.y;
      strategy.value = position.strategy;
      placement.value = position.placement;
      middlewareData.value = position.middlewareData;
      isPositioned.value = true;
    });
  }
  function cleanup() {
    if (typeof whileElementsMountedCleanup === "function") {
      whileElementsMountedCleanup();
      whileElementsMountedCleanup = void 0;
    }
  }
  function attach() {
    cleanup();
    if (whileElementsMountedOption === void 0) {
      update();
      return;
    }
    if (referenceElement.value != null && floatingElement.value != null) {
      whileElementsMountedCleanup = whileElementsMountedOption(referenceElement.value, floatingElement.value, update);
      return;
    }
  }
  function reset() {
    if (!openOption.value) {
      isPositioned.value = false;
    }
  }
  watch([middlewareOption, placementOption, strategyOption], update, {
    flush: "sync"
  });
  watch([referenceElement, floatingElement], attach, {
    flush: "sync"
  });
  watch(openOption, reset, {
    flush: "sync"
  });
  if (getCurrentScope()) {
    onScopeDispose(cleanup);
  }
  return {
    x: shallowReadonly(x),
    y: shallowReadonly(y),
    strategy: shallowReadonly(strategy),
    placement: shallowReadonly(placement),
    middlewareData: shallowReadonly(middlewareData),
    isPositioned: shallowReadonly(isPositioned),
    update
  };
}

// node_modules/@headlessui-float/vue/dist/headlessui-float.mjs
var ce = Object.defineProperty;
var de = (e, r, o) => r in e ? ce(e, r, { enumerable: true, configurable: true, writable: true, value: o }) : e[r] = o;
var H = (e, r, o) => (de(e, typeof r != "symbol" ? r + "" : r, o), o);
function j(e) {
  var _a;
  if (e == null || e.value == null)
    return null;
  const r = (_a = e.value.$el) != null ? _a : e.value;
  return r.$el ? j(ref(r)) : r;
}
var Oe = class {
  constructor() {
    H(this, "current", this.detect());
  }
  set(r) {
    this.current !== r && (this.current = r);
  }
  reset() {
    this.set(this.detect());
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window > "u" || typeof document > "u" ? "server" : "client";
  }
};
var z = new Oe();
function D(e) {
  return e.reduce((r, o) => o.type === Fragment ? r.concat(D(o.children)) : r.concat(o), []);
}
function I(e) {
  return e == null ? false : typeof e.type == "string" || typeof e.type == "object" || typeof e.type == "function";
}
function W(e) {
  return e = unref(e), e && (e == null ? void 0 : e.nodeType) !== Node.COMMENT_NODE;
}
function K(e) {
  if (z.isServer)
    return null;
  if (e instanceof Node)
    return e.ownerDocument;
  if (Object.prototype.hasOwnProperty.call(e, "value")) {
    const r = j(e);
    if (r)
      return r.ownerDocument;
  }
  return document;
}
function Ne(e, r, o, i, t) {
  watch([
    () => t.offset,
    () => t.flip,
    () => t.shift,
    () => t.autoPlacement,
    () => t.arrow,
    () => t.hide,
    () => t.middleware
  ], () => {
    const a = [];
    (typeof t.offset == "number" || typeof t.offset == "object" || typeof t.offset == "function") && a.push(offset(t.offset)), (t.flip === true || typeof t.flip == "number" || typeof t.flip == "object") && a.push(flip(__spreadValues({
      padding: typeof t.flip == "number" ? t.flip : void 0
    }, typeof t.flip == "object" ? t.flip : {}))), (t.shift === true || typeof t.shift == "number" || typeof t.shift == "object") && a.push(shift(__spreadValues({
      padding: typeof t.shift == "number" ? t.shift : void 0
    }, typeof t.shift == "object" ? t.shift : {}))), (t.autoPlacement === true || typeof t.autoPlacement == "object") && a.push(autoPlacement(typeof t.autoPlacement == "object" ? t.autoPlacement : void 0)), (t.arrow === true || typeof t.arrow == "number") && a.push(arrow2({
      element: i,
      padding: t.arrow === true ? 0 : t.arrow
    })), a.push(...typeof t.middleware == "function" ? t.middleware({
      referenceEl: r,
      floatingEl: o
    }) : t.middleware || []), (t.hide === true || typeof t.hide == "object") && a.push(hide(typeof t.hide == "object" ? t.hide : void 0)), e.value = a;
  }, { immediate: true });
}
function Re(e, r, o) {
  let i = () => {
  };
  onMounted(() => {
    if (e && z.isClient && typeof ResizeObserver < "u" && r.value && r.value instanceof Element) {
      const t = new ResizeObserver(([a]) => {
        o.value = a.borderBoxSize.reduce((c, { inlineSize: s }) => c + s, 0);
      });
      t.observe(r.value), i = () => {
        t.disconnect(), o.value = null;
      };
    }
  }), onBeforeUnmount(() => {
    i();
  });
}
var Ge = [
  "origin-bottom",
  "origin-top",
  "origin-right",
  "origin-left",
  "origin-bottom-left",
  "origin-bottom-right",
  "origin-top-left",
  "origin-top-right"
];
var Be = (e) => {
  switch (e) {
    case "top":
      return "origin-bottom";
    case "bottom":
      return "origin-top";
    case "left":
      return "origin-right";
    case "right":
      return "origin-left";
    case "top-start":
    case "right-end":
      return "origin-bottom-left";
    case "top-end":
    case "left-end":
      return "origin-bottom-right";
    case "right-start":
    case "bottom-start":
      return "origin-top-left";
    case "left-start":
    case "bottom-end":
      return "origin-top-right";
    default:
      return "";
  }
};
function je(e, r) {
  const o = computed(() => {
    if (typeof e.originClass == "function")
      return e.originClass(r.value);
    if (typeof e.originClass == "string")
      return e.originClass;
    if (e.tailwindcssOriginClass)
      return Be(r.value);
  }), i = computed(() => e.enter || o.value ? `${e.enter || ""} ${o.value || ""}` : void 0), t = computed(() => e.leave || o.value ? `${e.leave || ""} ${o.value || ""}` : void 0);
  return { originClassRef: o, enterActiveClassRef: i, leaveActiveClassRef: t };
}
function Q(e, r, ...o) {
  if (e in r) {
    const t = r[e];
    return typeof t == "function" ? t(...o) : t;
  }
  const i = new Error(`Tried to handle "${e}" but there is no handler defined. Only defined handlers are: ${Object.keys(r).map((t) => `"${t}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(i, Q), i;
}
var _ = [
  "[contentEditable=true]",
  "[tabindex]",
  "a[href]",
  "area[href]",
  "button:not([disabled])",
  "iframe",
  "input:not([disabled])",
  "select:not([disabled])",
  "textarea:not([disabled])"
].map(false ? (e) => `${e}:not([tabindex='-1']):not([style*='display: none'])` : (e) => `${e}:not([tabindex='-1'])`).join(",");
var Z = ((e) => (e[e.Strict = 0] = "Strict", e[e.Loose = 1] = "Loose", e))(Z || {});
function $e(e, r = 0) {
  var o;
  return e === ((o = K(e)) == null ? void 0 : o.body) ? false : Q(r, {
    [0]() {
      return e.matches(_);
    },
    [1]() {
      let i = e;
      for (; i !== null; ) {
        if (i.matches(_))
          return true;
        i = i.parentElement;
      }
      return false;
    }
  });
}
function F(e, r, o) {
  z.isServer || watchEffect((i) => {
    document.addEventListener(e, r, o), i(() => document.removeEventListener(e, r, o));
  });
}
function Ve(e, r, o = computed(() => true)) {
  function i(a, c) {
    if (!o.value || a.defaultPrevented)
      return;
    const s = c(a);
    if (s === null || !s.getRootNode().contains(s))
      return;
    const u = function d(f) {
      return typeof f == "function" ? d(f()) : Array.isArray(f) || f instanceof Set ? f : [f];
    }(e);
    for (const d of u) {
      if (d === null)
        continue;
      const f = d instanceof HTMLElement ? d : j(d);
      if (f != null && f.contains(s) || a.composed && a.composedPath().includes(f))
        return;
    }
    return !$e(s, Z.Loose) && s.tabIndex !== -1 && a.preventDefault(), r(a, s);
  }
  const t = ref(null);
  F("mousedown", (a) => {
    var c, s;
    o.value && (t.value = ((s = (c = a.composedPath) == null ? void 0 : c.call(a)) == null ? void 0 : s[0]) || a.target);
  }, true), F("click", (a) => {
    t.value && (i(a, () => t.value), t.value = null);
  }, true), F("blur", (a) => i(a, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), true);
}
var ee = Symbol("ReferenceContext");
var te = Symbol("FloatingContext");
var ne = Symbol("ArrowContext");
function re(e) {
  const r = inject(ee, null);
  if (r === null) {
    const o = new Error(`<${e} /> must be in the <Float /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(o, re), o;
  }
  return r;
}
function oe(e) {
  const r = inject(te, null);
  if (r === null) {
    const o = new Error(`<${e} /> must be in the <Float /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(o, oe), o;
  }
  return r;
}
function ae(e) {
  const r = inject(ne, null);
  if (r === null) {
    const o = new Error(`<${e} /> must be in the <Float /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(o, ae), o;
  }
  return r;
}
var n = {
  as: {
    type: [String, Function],
    default: "template"
  },
  floatingAs: {
    type: [String, Function],
    default: "div"
  },
  show: {
    type: Boolean,
    default: null
  },
  placement: {
    type: String,
    default: "bottom-start"
  },
  strategy: {
    type: String,
    default: "absolute"
  },
  offset: [Number, Function, Object],
  shift: {
    type: [Boolean, Number, Object],
    default: false
  },
  flip: {
    type: [Boolean, Number, Object],
    default: false
  },
  arrow: {
    type: [Boolean, Number],
    default: false
  },
  autoPlacement: {
    type: [Boolean, Object],
    default: false
  },
  hide: {
    type: [Boolean, Object],
    default: false
  },
  autoUpdate: {
    type: [Boolean, Object],
    default: true
  },
  zIndex: {
    type: [Number, String],
    default: 9999
  },
  transitionName: String,
  transitionType: String,
  enter: String,
  enterFrom: String,
  enterTo: String,
  leave: String,
  leaveFrom: String,
  leaveTo: String,
  originClass: [String, Function],
  tailwindcssOriginClass: {
    type: Boolean,
    default: false
  },
  portal: {
    type: Boolean,
    default: false
  },
  transform: {
    type: Boolean,
    default: true
  },
  adaptiveWidth: {
    type: Boolean,
    default: false
  },
  composable: {
    type: Boolean,
    default: false
  },
  dialog: {
    type: Boolean,
    default: false
  },
  middleware: {
    type: [Array, Function],
    default: () => []
  }
};
function ie(e, r, o, i) {
  const { referenceRef: t } = i, a = r, c = mergeProps(o, {
    ref: t
  }), s = cloneVNode(e, a.as === "template" ? c : {});
  return a.as === "template" ? s : typeof a.as == "string" ? h(a.as, c, [s]) : h(a.as, c, () => [s]);
}
function L(e, r, o, i) {
  const { floatingRef: t, props: a, mounted: c, show: s, x: u, y: d, placement: f, strategy: h2, referenceElWidth: m, updateFloating: y } = i, l = mergeProps(__spreadProps(__spreadValues({}, a), { as: a.floatingAs }), r), { enterActiveClassRef: v, leaveActiveClassRef: C } = je(l, f), E = {
    enterActiveClass: v.value,
    enterFromClass: l.enterFrom,
    enterToClass: l.enterTo,
    leaveActiveClass: C.value,
    leaveFromClass: l.leaveFrom,
    leaveToClass: l.leaveTo
  }, x = __spreadProps(__spreadValues({
    name: l.transitionName,
    type: l.transitionType,
    appear: true
  }, l.transitionName ? {} : E), {
    onBeforeEnter() {
      s.value = true;
    },
    onAfterLeave() {
      s.value = false;
    }
  }), R2 = {
    enter: v.value,
    enterFrom: l.enterFrom,
    enterTo: l.enterTo,
    leave: C.value,
    leaveFrom: l.leaveFrom,
    leaveTo: l.leaveTo,
    onBeforeEnter: x.onBeforeEnter,
    onAfterLeave: x.onAfterLeave
  }, $ = {
    style: __spreadProps(__spreadValues({}, !l.dialog && l.transform ? {
      position: h2.value,
      zIndex: l.zIndex,
      top: "0px",
      left: "0px",
      right: "auto",
      bottom: "auto",
      transform: `translate(${Math.round(u.value || 0)}px,${Math.round(d.value || 0)}px)`
    } : {
      position: h2.value,
      zIndex: l.zIndex,
      top: `${d.value || 0}px`,
      left: `${u.value || 0}px`
    }), {
      width: l.adaptiveWidth && typeof m.value == "number" ? `${m.value}px` : void 0
    })
  };
  function V(w) {
    return l.portal ? h(R, () => w) : w;
  }
  function P(w) {
    const A = mergeProps($, o, l.dialog ? {} : { ref: t });
    return l.as === "template" ? w : typeof l.as == "string" ? h(l.as, A, w) : h(l.as, A, () => w);
  }
  function B() {
    function w() {
      var b;
      const A = l.as === "template" ? mergeProps($, o, l.dialog ? {} : { ref: t }) : null, S = cloneVNode(e, A);
      return ((b = S.props) == null ? void 0 : b.unmount) === false ? (y(), S) : typeof l.show != "boolean" || l.show ? S : createCommentVNode();
    }
    return z.isServer ? c.value && l.show ? w() : createCommentVNode() : l.transitionChild ? h(he, __spreadValues(__spreadProps(__spreadValues({
      key: `placement-${f.value}`
    }, l.dialog ? { ref: t } : {}), {
      as: "template"
    }), R2), w) : h(Transition, __spreadValues(__spreadValues({}, l.dialog ? { ref: t } : {}), x), w);
  }
  return V(P(B()));
}
function le(e, r, o, i, t) {
  const a = ref(false), c = toRef(i, "placement"), s = toRef(i, "strategy"), u = shallowRef({}), d = ref(null), f = ref(void 0), h2 = ref(void 0), m = computed(() => j(r)), y = computed(() => j(o)), l = computed(() => W(m) && W(y)), { x: v, y: C, placement: E, strategy: x, middlewareData: R2, update: $ } = useFloating(m, y, {
    placement: c,
    strategy: s,
    middleware: u,
    whileElementsMounted: () => {
    }
  }), V = ref(null);
  onMounted(() => {
    a.value = true;
  });
  function P() {
    l.value && ($(), t("update"));
  }
  watch([c, s, u], P, { flush: "sync" }), Ne(u, m, y, d, i), watch(R2, () => {
    const b = R2.value.arrow;
    f.value = b == null ? void 0 : b.x, h2.value = b == null ? void 0 : b.y;
  }), Re(i.adaptiveWidth, m, V), watch(e, async (b, He, ue) => {
    if (await nextTick(), e.value && l.value && i.autoUpdate) {
      const fe = autoUpdate(m.value, y.value, P, typeof i.autoUpdate == "object" ? i.autoUpdate : void 0);
      t("show"), ue(() => {
        fe(), e.value || t("hide");
      });
    }
  }, { flush: "post", immediate: true });
  const B = ref(true);
  watch(m, () => {
    !(m.value instanceof Element) && l.value && B.value && (B.value = false, window.requestAnimationFrame(() => {
      B.value = true, P();
    }));
  }, { flush: "sync" });
  const w = {
    referenceRef: r,
    placement: E
  }, A = {
    floatingRef: o,
    props: i,
    mounted: a,
    show: e,
    x: v,
    y: C,
    placement: E,
    strategy: x,
    referenceElWidth: V,
    updateFloating: P
  }, S = {
    ref: d,
    placement: E,
    x: f,
    y: h2
  };
  return provide(ne, S), { referenceApi: w, floatingApi: A, arrowApi: S, x: v, y: C, placement: E, strategy: x, referenceEl: m, floatingEl: y, middlewareData: R2, update: P };
}
var Ie = {
  name: "Float",
  inheritAttrs: false,
  props: n,
  emits: ["show", "hide", "update"],
  setup(e, { emit: r, slots: o, attrs: i }) {
    var _a;
    const t = ref((_a = e.show) != null ? _a : false), a = ref(null), c = ref(null), {
      referenceApi: s,
      floatingApi: u,
      placement: d
    } = le(t, a, c, e, r);
    function f(m) {
      return e.as === "template" ? m : typeof e.as == "string" ? h(e.as, i, m) : h(e.as, i, () => m);
    }
    const h2 = {
      placement: d.value
    };
    return e.composable || e.dialog ? (provide(ee, s), provide(te, u), () => {
      if (o.default)
        return f(o.default(h2));
    }) : () => {
      if (!o.default)
        return;
      const [m, y] = D(o.default(h2)).filter(I);
      if (!I(m))
        return;
      const l = ie(m, { as: "template" }, {}, s), v = L(y, { as: e.floatingAs }, {}, u);
      return f([
        l,
        v
      ]);
    };
  }
};
var ze = {
  as: n.as
};
var Je = {
  name: "FloatReference",
  inheritAttrs: false,
  props: ze,
  setup(e, { slots: r, attrs: o }) {
    const i = re("FloatReference"), { placement: t } = i;
    return () => {
      if (!r.default)
        return;
      const a = {
        placement: t.value
      };
      return ie(r.default(a)[0], e, o, i);
    };
  }
};
var q = {
  as: n.floatingAs,
  transitionName: n.transitionName,
  transitionType: n.transitionType,
  enter: n.enter,
  enterFrom: n.enterFrom,
  enterTo: n.enterTo,
  leave: n.leave,
  leaveFrom: n.leaveFrom,
  leaveTo: n.leaveTo,
  originClass: n.originClass,
  tailwindcssOriginClass: n.tailwindcssOriginClass,
  transitionChild: {
    type: Boolean,
    default: false
  }
};
var Ke = {
  name: "FloatContent",
  inheritAttrs: false,
  props: q,
  setup(e, { slots: r, attrs: o }) {
    const i = oe("FloatContent"), { placement: t } = i;
    return () => {
      if (!r.default)
        return;
      const a = {
        placement: t.value
      }, c = Object.entries(e).reduce((s, [u, d]) => {
        const f = q;
        return (typeof f[u] == "object" && d === f[u].default || d === void 0) && delete s[u], s;
      }, __spreadValues({}, e));
      return L(r.default(a)[0], c, o, i);
    };
  }
};
var Ue = {
  as: __spreadProps(__spreadValues({}, n.as), {
    default: "div"
  }),
  offset: {
    type: Number,
    default: 4
  }
};
var Qe = {
  name: "FloatArrow",
  props: Ue,
  setup(e, { slots: r, attrs: o }) {
    const { ref: i, placement: t, x: a, y: c } = ae("FloatArrow");
    return () => {
      var d;
      const s = {
        top: "bottom",
        right: "left",
        bottom: "top",
        left: "right"
      }[t.value.split("-")[0]], u = {
        left: typeof a.value == "number" ? `${a.value}px` : void 0,
        top: typeof c.value == "number" ? `${c.value}px` : void 0,
        right: void 0,
        bottom: void 0,
        [s]: `${e.offset * -1}px`
      };
      if (e.as === "template") {
        const f = {
          placement: t.value
        }, h2 = (d = r.default) == null ? void 0 : d.call(r, f)[0];
        return !h2 || !I(h2) ? void 0 : cloneVNode(h2, { ref: i, style: u });
      }
      return h(e.as, mergeProps(o, { ref: i, style: u }));
    };
  }
};
var Me = {
  as: n.as,
  show: n.show,
  placement: n.placement,
  strategy: n.strategy,
  offset: n.offset,
  shift: n.shift,
  flip: n.flip,
  arrow: n.arrow,
  autoPlacement: n.autoPlacement,
  hide: n.hide,
  autoUpdate: n.autoUpdate,
  zIndex: n.zIndex,
  transitionName: n.transitionName,
  transitionType: n.transitionType,
  enter: n.enter,
  enterFrom: n.enterFrom,
  enterTo: n.enterTo,
  leave: n.leave,
  leaveFrom: n.leaveFrom,
  leaveTo: n.leaveTo,
  originClass: n.originClass,
  tailwindcssOriginClass: n.tailwindcssOriginClass,
  portal: n.portal,
  transform: n.transform,
  middleware: n.middleware
};
var se = {
  name: "FloatVirtual",
  inheritAttrs: false,
  props: Me,
  emits: ["initial", "show", "hide", "update"],
  setup(e, { emit: r, slots: o, attrs: i }) {
    var _a;
    const t = ref((_a = e.show) != null ? _a : false), a = ref({
      getBoundingClientRect() {
        return {
          x: 0,
          y: 0,
          top: 0,
          left: 0,
          bottom: 0,
          right: 0,
          width: 0,
          height: 0
        };
      }
    }), c = ref(null), {
      floatingApi: s,
      placement: u
    } = le(t, a, c, e, r);
    watch(() => e.show, () => {
      var _a2;
      t.value = (_a2 = e.show) != null ? _a2 : false;
    });
    function d() {
      t.value = false;
    }
    return r("initial", {
      show: t,
      placement: u,
      reference: a,
      floating: c
    }), () => {
      if (!o.default)
        return;
      const f = {
        placement: u.value,
        close: d
      }, [h2] = D(o.default(f)).filter(I);
      return L(h2, {
        as: e.as,
        show: t.value
      }, i, s);
    };
  }
};
var ke = {
  as: n.as,
  placement: n.placement,
  strategy: n.strategy,
  offset: n.offset,
  shift: n.shift,
  flip: __spreadProps(__spreadValues({}, n.flip), {
    default: true
  }),
  arrow: n.arrow,
  autoPlacement: n.autoPlacement,
  hide: n.hide,
  autoUpdate: n.autoUpdate,
  zIndex: n.zIndex,
  transitionName: n.transitionName,
  transitionType: n.transitionType,
  enter: n.enter,
  enterFrom: n.enterFrom,
  enterTo: n.enterTo,
  leave: n.leave,
  leaveFrom: n.leaveFrom,
  leaveTo: n.leaveTo,
  originClass: n.originClass,
  tailwindcssOriginClass: n.tailwindcssOriginClass,
  transform: n.transform,
  middleware: n.middleware
};
var Ze = {
  name: "FloatContextMenu",
  inheritAttrs: false,
  props: ke,
  emits: ["show", "hide", "update"],
  setup(e, { emit: r, slots: o, attrs: i }) {
    function t({ show: a, reference: c, floating: s }) {
      F("contextmenu", (u) => {
        u.preventDefault(), c.value = {
          getBoundingClientRect() {
            return {
              width: 0,
              height: 0,
              x: u.clientX,
              y: u.clientY,
              top: u.clientY,
              left: u.clientX,
              right: u.clientX,
              bottom: u.clientY
            };
          }
        }, a.value = true;
      }), Ve(s, () => {
        a.value = false;
      }, computed(() => a.value));
    }
    return () => {
      if (o.default)
        return h(se, __spreadProps(__spreadValues(__spreadValues({}, e), i), {
          portal: true,
          onInitial: t,
          onShow: () => r("show"),
          onHide: () => r("hide"),
          onUpdate: () => r("update")
        }), o.default);
    };
  }
};
var De = {
  as: n.as,
  placement: n.placement,
  strategy: n.strategy,
  offset: n.offset,
  shift: n.shift,
  flip: n.flip,
  arrow: n.arrow,
  autoPlacement: n.autoPlacement,
  hide: n.hide,
  autoUpdate: n.autoUpdate,
  zIndex: n.zIndex,
  transitionName: n.transitionName,
  transitionType: n.transitionType,
  enter: n.enter,
  enterFrom: n.enterFrom,
  enterTo: n.enterTo,
  leave: n.leave,
  leaveFrom: n.leaveFrom,
  leaveTo: n.leaveTo,
  originClass: n.originClass,
  tailwindcssOriginClass: n.tailwindcssOriginClass,
  transform: n.transform,
  middleware: n.middleware,
  globalHideCursor: {
    type: Boolean,
    default: true
  }
};
var et = {
  name: "FloatCursor",
  inheritAttrs: false,
  props: De,
  emits: ["show", "hide", "update"],
  setup(_a, { emit: o, slots: i, attrs: t }) {
    var _b = _a, { globalHideCursor: e } = _b, r = __objRest(_b, ["globalHideCursor"]);
    function a({ show: c, reference: s, floating: u }) {
      function d() {
        c.value = true;
      }
      function f() {
        c.value = false;
      }
      function h2(v) {
        s.value = {
          getBoundingClientRect() {
            return {
              width: 0,
              height: 0,
              x: v.clientX,
              y: v.clientY,
              top: v.clientY,
              left: v.clientX,
              right: v.clientX,
              bottom: v.clientY
            };
          }
        };
      }
      function m(v) {
        d(), h2(v);
      }
      function y(v) {
        d(), h2(v.touches[0]);
      }
      const l = K(u);
      l && (watchEffect((v) => {
        if (e && !l.getElementById("headlesui-float-cursor-style")) {
          const C = l.createElement("style");
          (l.head || l.getElementsByTagName("head")[0]).appendChild(C), C.id = "headlesui-float-cursor-style", C.appendChild(l.createTextNode([
            "*, *::before, *::after {",
            "  cursor: none !important;",
            "}",
            ".headlesui-float-cursor-root {",
            "  pointer-events: none !important;",
            "}"
          ].join(`
`))), v(() => {
            var x;
            return (x = l.getElementById("headlesui-float-cursor-style")) == null ? void 0 : x.remove();
          });
        }
      }, { flush: "post" }), "ontouchstart" in window || navigator.maxTouchPoints > 0 ? (F("touchstart", y), F("touchend", f), F("touchmove", y)) : (F("mouseenter", m), F("mouseleave", f), F("mousemove", m)));
    }
    return () => {
      if (i.default)
        return h(se, __spreadProps(__spreadValues(__spreadValues({}, r), t), {
          portal: true,
          class: "headlesui-float-cursor-root",
          onInitial: a,
          onShow: () => o("show"),
          onHide: () => o("hide"),
          onUpdate: () => o("update")
        }), i.default);
    };
  }
};
function tt(e) {
  return (r, { slots: o }) => h(Ie, mergeProps(e, r), o);
}
var Le = [
  "Float",
  "FloatArrow"
];
function nt(e = {}) {
  const { prefix: r = "" } = e;
  return {
    type: "component",
    resolve: (o) => {
      if (o.startsWith(r)) {
        const i = o.substring(r.length);
        if (Le.includes(i))
          return {
            name: i,
            from: "@headlessui-float/vue"
          };
      }
    }
  };
}
export {
  Ie as Float,
  Qe as FloatArrow,
  Ue as FloatArrowPropsValidators,
  Ke as FloatContent,
  q as FloatContentPropsValidators,
  Ze as FloatContextMenu,
  ke as FloatContextMenuPropsValidators,
  et as FloatCursor,
  De as FloatCursorPropsValidators,
  n as FloatPropsValidators,
  Je as FloatReference,
  ze as FloatReferencePropsValidators,
  se as FloatVirtual,
  Me as FloatVirtualPropsValidators,
  nt as HeadlessUiFloatResolver,
  tt as createHighOrderFloatComponent,
  L as renderFloatingElement,
  ie as renderReferenceElement,
  Be as tailwindcssOriginClassResolver,
  Ge as tailwindcssOriginSafelist,
  le as useFloat,
  Ve as useOutsideClick
};
//# sourceMappingURL=@headlessui-float_vue.js.map
