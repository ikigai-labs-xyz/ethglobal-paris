{
  "version": 3,
  "sources": ["dep:@headlessui-float_vue", "../../@headlessui-float/vue/dist/headlessui-float.mjs", "../../@floating-ui/vue/dist/floating-ui.vue.esm.js", "../../@floating-ui/dom/dist/floating-ui.dom.esm.js", "../../@floating-ui/core/dist/floating-ui.core.esm.js"],
  "sourcesContent": ["\nexport * from \"./node_modules/@headlessui-float/vue/dist/headlessui-float.mjs\"", "var ce = Object.defineProperty;\nvar de = (e, r, o) => r in e ? ce(e, r, { enumerable: !0, configurable: !0, writable: !0, value: o }) : e[r] = o;\nvar H = (e, r, o) => (de(e, typeof r != \"symbol\" ? r + \"\" : r, o), o);\nimport { ref as g, Fragment as me, unref as ve, watch as O, onMounted as G, onBeforeUnmount as he, computed as T, watchEffect as J, mergeProps as N, cloneVNode as M, h as p, toRef as X, shallowRef as ge, nextTick as pe, provide as U, inject as k, createCommentVNode as Y, Transition as ye } from \"vue\";\nimport { Portal as we, TransitionChild as be } from \"@headlessui/vue\";\nimport { arrow as Fe, useFloating as Ce } from \"@floating-ui/vue\";\nimport { offset as xe, flip as Te, shift as Ee, autoPlacement as Pe, hide as Ae, autoUpdate as Se } from \"@floating-ui/dom\";\nfunction j(e) {\n  if (e == null || e.value == null)\n    return null;\n  const r = e.value.$el ?? e.value;\n  return r.$el ? j(g(r)) : r;\n}\nclass Oe {\n  constructor() {\n    H(this, \"current\", this.detect());\n  }\n  set(r) {\n    this.current !== r && (this.current = r);\n  }\n  reset() {\n    this.set(this.detect());\n  }\n  get isServer() {\n    return this.current === \"server\";\n  }\n  get isClient() {\n    return this.current === \"client\";\n  }\n  detect() {\n    return typeof window > \"u\" || typeof document > \"u\" ? \"server\" : \"client\";\n  }\n}\nconst z = new Oe();\nfunction D(e) {\n  return e.reduce((r, o) => o.type === me ? r.concat(D(o.children)) : r.concat(o), []);\n}\nfunction I(e) {\n  return e == null ? !1 : typeof e.type == \"string\" || typeof e.type == \"object\" || typeof e.type == \"function\";\n}\nfunction W(e) {\n  return e = ve(e), e && (e == null ? void 0 : e.nodeType) !== Node.COMMENT_NODE;\n}\nfunction K(e) {\n  if (z.isServer)\n    return null;\n  if (e instanceof Node)\n    return e.ownerDocument;\n  if (Object.prototype.hasOwnProperty.call(e, \"value\")) {\n    const r = j(e);\n    if (r)\n      return r.ownerDocument;\n  }\n  return document;\n}\nfunction Ne(e, r, o, i, t) {\n  O([\n    () => t.offset,\n    () => t.flip,\n    () => t.shift,\n    () => t.autoPlacement,\n    () => t.arrow,\n    () => t.hide,\n    () => t.middleware\n  ], () => {\n    const a = [];\n    (typeof t.offset == \"number\" || typeof t.offset == \"object\" || typeof t.offset == \"function\") && a.push(xe(t.offset)), (t.flip === !0 || typeof t.flip == \"number\" || typeof t.flip == \"object\") && a.push(Te({\n      padding: typeof t.flip == \"number\" ? t.flip : void 0,\n      ...typeof t.flip == \"object\" ? t.flip : {}\n    })), (t.shift === !0 || typeof t.shift == \"number\" || typeof t.shift == \"object\") && a.push(Ee({\n      padding: typeof t.shift == \"number\" ? t.shift : void 0,\n      ...typeof t.shift == \"object\" ? t.shift : {}\n    })), (t.autoPlacement === !0 || typeof t.autoPlacement == \"object\") && a.push(Pe(\n      typeof t.autoPlacement == \"object\" ? t.autoPlacement : void 0\n    )), (t.arrow === !0 || typeof t.arrow == \"number\") && a.push(Fe({\n      element: i,\n      padding: t.arrow === !0 ? 0 : t.arrow\n    })), a.push(...typeof t.middleware == \"function\" ? t.middleware({\n      referenceEl: r,\n      floatingEl: o\n    }) : t.middleware || []), (t.hide === !0 || typeof t.hide == \"object\") && a.push(Ae(\n      typeof t.hide == \"object\" ? t.hide : void 0\n    )), e.value = a;\n  }, { immediate: !0 });\n}\nfunction Re(e, r, o) {\n  let i = () => {\n  };\n  G(() => {\n    if (e && z.isClient && typeof ResizeObserver < \"u\" && r.value && r.value instanceof Element) {\n      const t = new ResizeObserver(([a]) => {\n        o.value = a.borderBoxSize.reduce((c, { inlineSize: s }) => c + s, 0);\n      });\n      t.observe(r.value), i = () => {\n        t.disconnect(), o.value = null;\n      };\n    }\n  }), he(() => {\n    i();\n  });\n}\nconst Ge = [\n  \"origin-bottom\",\n  \"origin-top\",\n  \"origin-right\",\n  \"origin-left\",\n  \"origin-bottom-left\",\n  \"origin-bottom-right\",\n  \"origin-top-left\",\n  \"origin-top-right\"\n], Be = (e) => {\n  switch (e) {\n    case \"top\":\n      return \"origin-bottom\";\n    case \"bottom\":\n      return \"origin-top\";\n    case \"left\":\n      return \"origin-right\";\n    case \"right\":\n      return \"origin-left\";\n    case \"top-start\":\n    case \"right-end\":\n      return \"origin-bottom-left\";\n    case \"top-end\":\n    case \"left-end\":\n      return \"origin-bottom-right\";\n    case \"right-start\":\n    case \"bottom-start\":\n      return \"origin-top-left\";\n    case \"left-start\":\n    case \"bottom-end\":\n      return \"origin-top-right\";\n    default:\n      return \"\";\n  }\n};\nfunction je(e, r) {\n  const o = T(() => {\n    if (typeof e.originClass == \"function\")\n      return e.originClass(r.value);\n    if (typeof e.originClass == \"string\")\n      return e.originClass;\n    if (e.tailwindcssOriginClass)\n      return Be(r.value);\n  }), i = T(\n    () => e.enter || o.value ? `${e.enter || \"\"} ${o.value || \"\"}` : void 0\n  ), t = T(\n    () => e.leave || o.value ? `${e.leave || \"\"} ${o.value || \"\"}` : void 0\n  );\n  return { originClassRef: o, enterActiveClassRef: i, leaveActiveClassRef: t };\n}\nfunction Q(e, r, ...o) {\n  if (e in r) {\n    const t = r[e];\n    return typeof t == \"function\" ? t(...o) : t;\n  }\n  const i = new Error(\n    `Tried to handle \"${e}\" but there is no handler defined. Only defined handlers are: ${Object.keys(\n      r\n    ).map((t) => `\"${t}\"`).join(\", \")}.`\n  );\n  throw Error.captureStackTrace && Error.captureStackTrace(i, Q), i;\n}\nconst _ = [\n  \"[contentEditable=true]\",\n  \"[tabindex]\",\n  \"a[href]\",\n  \"area[href]\",\n  \"button:not([disabled])\",\n  \"iframe\",\n  \"input:not([disabled])\",\n  \"select:not([disabled])\",\n  \"textarea:not([disabled])\"\n].map(\n  // TODO: Remove this once JSDOM fixes the issue where an element that is\n  // \"hidden\" can be the document.activeElement, because this is not possible\n  // in real browsers.\n  process.env.NODE_ENV === \"test\" ? (e) => `${e}:not([tabindex='-1']):not([style*='display: none'])` : (e) => `${e}:not([tabindex='-1'])`\n).join(\",\");\nvar Z = /* @__PURE__ */ ((e) => (e[e.Strict = 0] = \"Strict\", e[e.Loose = 1] = \"Loose\", e))(Z || {});\nfunction $e(e, r = 0) {\n  var o;\n  return e === ((o = K(e)) == null ? void 0 : o.body) ? !1 : Q(r, {\n    [\n      0\n      /* Strict */\n    ]() {\n      return e.matches(_);\n    },\n    [\n      1\n      /* Loose */\n    ]() {\n      let i = e;\n      for (; i !== null; ) {\n        if (i.matches(_))\n          return !0;\n        i = i.parentElement;\n      }\n      return !1;\n    }\n  });\n}\nfunction F(e, r, o) {\n  z.isServer || J((i) => {\n    document.addEventListener(e, r, o), i(() => document.removeEventListener(e, r, o));\n  });\n}\nfunction Ve(e, r, o = T(() => !0)) {\n  function i(a, c) {\n    if (!o.value || a.defaultPrevented)\n      return;\n    const s = c(a);\n    if (s === null || !s.getRootNode().contains(s))\n      return;\n    const u = function d(f) {\n      return typeof f == \"function\" ? d(f()) : Array.isArray(f) || f instanceof Set ? f : [f];\n    }(e);\n    for (const d of u) {\n      if (d === null)\n        continue;\n      const f = d instanceof HTMLElement ? d : j(d);\n      if (f != null && f.contains(s) || a.composed && a.composedPath().includes(f))\n        return;\n    }\n    return (\n      // This check alllows us to know whether or not we clicked on a \"focusable\" element like a\n      // button or an input. This is a backwards compatibility check so that you can open a <Menu\n      // /> and click on another <Menu /> which should close Menu A and open Menu B. We might\n      // revisit that so that you will require 2 clicks instead.\n      !$e(s, Z.Loose) && // This could be improved, but the `Combobox.Button` adds tabIndex={-1} to make it\n      // unfocusable via the keyboard so that tabbing to the next item from the input doesn't\n      // first go to the button.\n      s.tabIndex !== -1 && a.preventDefault(), r(a, s)\n    );\n  }\n  const t = g(null);\n  F(\"mousedown\", (a) => {\n    var c, s;\n    o.value && (t.value = ((s = (c = a.composedPath) == null ? void 0 : c.call(a)) == null ? void 0 : s[0]) || a.target);\n  }, !0), F(\n    \"click\",\n    (a) => {\n      t.value && (i(a, () => t.value), t.value = null);\n    },\n    // We will use the `capture` phase so that layers in between with `event.stopPropagation()`\n    // don't \"cancel\" this outside click check. E.g.: A `Menu` inside a `DialogPanel` if the `Menu`\n    // is open, and you click outside of it in the `DialogPanel` the `Menu` should close. However,\n    // the `DialogPanel` has a `onClick(e) { e.stopPropagation() }` which would cancel this.\n    !0\n  ), F(\"blur\", (a) => i(\n    a,\n    () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null\n  ), !0);\n}\nconst ee = Symbol(\"ReferenceContext\"), te = Symbol(\"FloatingContext\"), ne = Symbol(\"ArrowContext\");\nfunction re(e) {\n  const r = k(ee, null);\n  if (r === null) {\n    const o = new Error(`<${e} /> must be in the <Float /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(o, re), o;\n  }\n  return r;\n}\nfunction oe(e) {\n  const r = k(te, null);\n  if (r === null) {\n    const o = new Error(`<${e} /> must be in the <Float /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(o, oe), o;\n  }\n  return r;\n}\nfunction ae(e) {\n  const r = k(ne, null);\n  if (r === null) {\n    const o = new Error(`<${e} /> must be in the <Float /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(o, ae), o;\n  }\n  return r;\n}\nconst n = {\n  as: {\n    type: [String, Function],\n    default: \"template\"\n  },\n  floatingAs: {\n    type: [String, Function],\n    default: \"div\"\n  },\n  show: {\n    type: Boolean,\n    default: null\n  },\n  placement: {\n    type: String,\n    default: \"bottom-start\"\n  },\n  strategy: {\n    type: String,\n    default: \"absolute\"\n  },\n  offset: [Number, Function, Object],\n  shift: {\n    type: [Boolean, Number, Object],\n    default: !1\n  },\n  flip: {\n    type: [Boolean, Number, Object],\n    default: !1\n  },\n  arrow: {\n    type: [Boolean, Number],\n    default: !1\n  },\n  autoPlacement: {\n    type: [Boolean, Object],\n    default: !1\n  },\n  hide: {\n    type: [Boolean, Object],\n    default: !1\n  },\n  autoUpdate: {\n    type: [Boolean, Object],\n    default: !0\n  },\n  zIndex: {\n    type: [Number, String],\n    default: 9999\n  },\n  transitionName: String,\n  transitionType: String,\n  enter: String,\n  enterFrom: String,\n  enterTo: String,\n  leave: String,\n  leaveFrom: String,\n  leaveTo: String,\n  originClass: [String, Function],\n  tailwindcssOriginClass: {\n    type: Boolean,\n    default: !1\n  },\n  portal: {\n    type: Boolean,\n    default: !1\n  },\n  transform: {\n    type: Boolean,\n    default: !0\n  },\n  adaptiveWidth: {\n    type: Boolean,\n    default: !1\n  },\n  composable: {\n    type: Boolean,\n    default: !1\n  },\n  dialog: {\n    type: Boolean,\n    default: !1\n  },\n  middleware: {\n    type: [Array, Function],\n    default: () => []\n  }\n};\nfunction ie(e, r, o, i) {\n  const { referenceRef: t } = i, a = r, c = N(o, {\n    ref: t\n  }), s = M(\n    e,\n    a.as === \"template\" ? c : {}\n  );\n  return a.as === \"template\" ? s : typeof a.as == \"string\" ? p(a.as, c, [s]) : p(a.as, c, () => [s]);\n}\nfunction L(e, r, o, i) {\n  const { floatingRef: t, props: a, mounted: c, show: s, x: u, y: d, placement: f, strategy: h, referenceElWidth: m, updateFloating: y } = i, l = N(\n    { ...a, as: a.floatingAs },\n    r\n  ), { enterActiveClassRef: v, leaveActiveClassRef: C } = je(l, f), E = {\n    enterActiveClass: v.value,\n    enterFromClass: l.enterFrom,\n    enterToClass: l.enterTo,\n    leaveActiveClass: C.value,\n    leaveFromClass: l.leaveFrom,\n    leaveToClass: l.leaveTo\n  }, x = {\n    name: l.transitionName,\n    type: l.transitionType,\n    appear: !0,\n    ...l.transitionName ? {} : E,\n    onBeforeEnter() {\n      s.value = !0;\n    },\n    onAfterLeave() {\n      s.value = !1;\n    }\n  }, R = {\n    enter: v.value,\n    enterFrom: l.enterFrom,\n    enterTo: l.enterTo,\n    leave: C.value,\n    leaveFrom: l.leaveFrom,\n    leaveTo: l.leaveTo,\n    onBeforeEnter: x.onBeforeEnter,\n    onAfterLeave: x.onAfterLeave\n  }, $ = {\n    style: {\n      // If enable dialog mode, then set `transform` to false.\n      ...!l.dialog && l.transform ? {\n        position: h.value,\n        zIndex: l.zIndex,\n        top: \"0px\",\n        left: \"0px\",\n        right: \"auto\",\n        bottom: \"auto\",\n        transform: `translate(${Math.round(u.value || 0)}px,${Math.round(d.value || 0)}px)`\n      } : {\n        position: h.value,\n        zIndex: l.zIndex,\n        top: `${d.value || 0}px`,\n        left: `${u.value || 0}px`\n      },\n      width: l.adaptiveWidth && typeof m.value == \"number\" ? `${m.value}px` : void 0\n    }\n  };\n  function V(w) {\n    return l.portal ? p(we, () => w) : w;\n  }\n  function P(w) {\n    const A = N(\n      $,\n      o,\n      l.dialog ? {} : { ref: t }\n    );\n    return l.as === \"template\" ? w : typeof l.as == \"string\" ? p(l.as, A, w) : p(l.as, A, () => w);\n  }\n  function B() {\n    function w() {\n      var b;\n      const A = l.as === \"template\" ? N(\n        $,\n        o,\n        l.dialog ? {} : { ref: t }\n      ) : null, S = M(e, A);\n      return ((b = S.props) == null ? void 0 : b.unmount) === !1 ? (y(), S) : typeof l.show != \"boolean\" || l.show ? S : Y();\n    }\n    return z.isServer ? c.value && l.show ? w() : Y() : l.transitionChild ? p(be, {\n      key: `placement-${f.value}`,\n      ...l.dialog ? { ref: t } : {},\n      as: \"template\",\n      ...R\n    }, w) : p(ye, {\n      ...l.dialog ? { ref: t } : {},\n      ...x\n    }, w);\n  }\n  return V(\n    P(\n      B()\n    )\n  );\n}\nfunction le(e, r, o, i, t) {\n  const a = g(!1), c = X(i, \"placement\"), s = X(i, \"strategy\"), u = ge({}), d = g(null), f = g(void 0), h = g(void 0), m = T(() => j(r)), y = T(() => j(o)), l = T(\n    () => W(m) && W(y)\n  ), { x: v, y: C, placement: E, strategy: x, middlewareData: R, update: $ } = Ce(m, y, {\n    placement: c,\n    strategy: s,\n    middleware: u,\n    whileElementsMounted: () => {\n    }\n  }), V = g(null);\n  G(() => {\n    a.value = !0;\n  });\n  function P() {\n    l.value && ($(), t(\"update\"));\n  }\n  O([c, s, u], P, { flush: \"sync\" }), Ne(\n    u,\n    m,\n    y,\n    d,\n    i\n  ), O(R, () => {\n    const b = R.value.arrow;\n    f.value = b == null ? void 0 : b.x, h.value = b == null ? void 0 : b.y;\n  }), Re(i.adaptiveWidth, m, V), O(e, async (b, He, ue) => {\n    if (await pe(), e.value && l.value && i.autoUpdate) {\n      const fe = Se(\n        m.value,\n        y.value,\n        P,\n        typeof i.autoUpdate == \"object\" ? i.autoUpdate : void 0\n      );\n      t(\"show\"), ue(() => {\n        fe(), e.value || t(\"hide\");\n      });\n    }\n  }, { flush: \"post\", immediate: !0 });\n  const B = g(!0);\n  O(m, () => {\n    !(m.value instanceof Element) && l.value && B.value && (B.value = !1, window.requestAnimationFrame(() => {\n      B.value = !0, P();\n    }));\n  }, { flush: \"sync\" });\n  const w = {\n    referenceRef: r,\n    placement: E\n  }, A = {\n    floatingRef: o,\n    props: i,\n    mounted: a,\n    show: e,\n    x: v,\n    y: C,\n    placement: E,\n    strategy: x,\n    referenceElWidth: V,\n    updateFloating: P\n  }, S = {\n    ref: d,\n    placement: E,\n    x: f,\n    y: h\n  };\n  return U(ne, S), { referenceApi: w, floatingApi: A, arrowApi: S, x: v, y: C, placement: E, strategy: x, referenceEl: m, floatingEl: y, middlewareData: R, update: P };\n}\nconst Ie = {\n  name: \"Float\",\n  inheritAttrs: !1,\n  props: n,\n  emits: [\"show\", \"hide\", \"update\"],\n  setup(e, { emit: r, slots: o, attrs: i }) {\n    const t = g(e.show ?? !1), a = g(null), c = g(null), {\n      referenceApi: s,\n      floatingApi: u,\n      placement: d\n    } = le(t, a, c, e, r);\n    function f(m) {\n      return e.as === \"template\" ? m : typeof e.as == \"string\" ? p(e.as, i, m) : p(e.as, i, () => m);\n    }\n    const h = {\n      placement: d.value\n    };\n    return e.composable || e.dialog ? (U(ee, s), U(te, u), () => {\n      if (o.default)\n        return f(o.default(h));\n    }) : () => {\n      if (!o.default)\n        return;\n      const [m, y] = D(o.default(h)).filter(I);\n      if (!I(m))\n        return;\n      const l = ie(\n        m,\n        { as: \"template\" },\n        {},\n        s\n      ), v = L(\n        y,\n        { as: e.floatingAs },\n        {},\n        u\n      );\n      return f([\n        l,\n        v\n      ]);\n    };\n  }\n}, ze = {\n  as: n.as\n}, Je = {\n  name: \"FloatReference\",\n  inheritAttrs: !1,\n  props: ze,\n  setup(e, { slots: r, attrs: o }) {\n    const i = re(\"FloatReference\"), { placement: t } = i;\n    return () => {\n      if (!r.default)\n        return;\n      const a = {\n        placement: t.value\n      };\n      return ie(\n        r.default(a)[0],\n        e,\n        o,\n        i\n      );\n    };\n  }\n}, q = {\n  as: n.floatingAs,\n  transitionName: n.transitionName,\n  transitionType: n.transitionType,\n  enter: n.enter,\n  enterFrom: n.enterFrom,\n  enterTo: n.enterTo,\n  leave: n.leave,\n  leaveFrom: n.leaveFrom,\n  leaveTo: n.leaveTo,\n  originClass: n.originClass,\n  tailwindcssOriginClass: n.tailwindcssOriginClass,\n  transitionChild: {\n    type: Boolean,\n    default: !1\n  }\n}, Ke = {\n  name: \"FloatContent\",\n  inheritAttrs: !1,\n  props: q,\n  setup(e, { slots: r, attrs: o }) {\n    const i = oe(\"FloatContent\"), { placement: t } = i;\n    return () => {\n      if (!r.default)\n        return;\n      const a = {\n        placement: t.value\n      }, c = Object.entries(e).reduce((s, [u, d]) => {\n        const f = q;\n        return (typeof f[u] == \"object\" && d === f[u].default || d === void 0) && delete s[u], s;\n      }, { ...e });\n      return L(\n        r.default(a)[0],\n        c,\n        o,\n        i\n      );\n    };\n  }\n}, Ue = {\n  as: {\n    ...n.as,\n    default: \"div\"\n  },\n  offset: {\n    type: Number,\n    default: 4\n  }\n}, Qe = {\n  name: \"FloatArrow\",\n  props: Ue,\n  setup(e, { slots: r, attrs: o }) {\n    const { ref: i, placement: t, x: a, y: c } = ae(\"FloatArrow\");\n    return () => {\n      var d;\n      const s = {\n        top: \"bottom\",\n        right: \"left\",\n        bottom: \"top\",\n        left: \"right\"\n      }[t.value.split(\"-\")[0]], u = {\n        left: typeof a.value == \"number\" ? `${a.value}px` : void 0,\n        top: typeof c.value == \"number\" ? `${c.value}px` : void 0,\n        right: void 0,\n        bottom: void 0,\n        [s]: `${e.offset * -1}px`\n      };\n      if (e.as === \"template\") {\n        const f = {\n          placement: t.value\n        }, h = (d = r.default) == null ? void 0 : d.call(r, f)[0];\n        return !h || !I(h) ? void 0 : M(h, { ref: i, style: u });\n      }\n      return p(e.as, N(o, { ref: i, style: u }));\n    };\n  }\n}, Me = {\n  as: n.as,\n  show: n.show,\n  placement: n.placement,\n  strategy: n.strategy,\n  offset: n.offset,\n  shift: n.shift,\n  flip: n.flip,\n  arrow: n.arrow,\n  autoPlacement: n.autoPlacement,\n  hide: n.hide,\n  autoUpdate: n.autoUpdate,\n  zIndex: n.zIndex,\n  transitionName: n.transitionName,\n  transitionType: n.transitionType,\n  enter: n.enter,\n  enterFrom: n.enterFrom,\n  enterTo: n.enterTo,\n  leave: n.leave,\n  leaveFrom: n.leaveFrom,\n  leaveTo: n.leaveTo,\n  originClass: n.originClass,\n  tailwindcssOriginClass: n.tailwindcssOriginClass,\n  portal: n.portal,\n  transform: n.transform,\n  middleware: n.middleware\n}, se = {\n  name: \"FloatVirtual\",\n  inheritAttrs: !1,\n  props: Me,\n  emits: [\"initial\", \"show\", \"hide\", \"update\"],\n  setup(e, { emit: r, slots: o, attrs: i }) {\n    const t = g(e.show ?? !1), a = g({\n      getBoundingClientRect() {\n        return {\n          x: 0,\n          y: 0,\n          top: 0,\n          left: 0,\n          bottom: 0,\n          right: 0,\n          width: 0,\n          height: 0\n        };\n      }\n    }), c = g(null), {\n      floatingApi: s,\n      placement: u\n    } = le(t, a, c, e, r);\n    O(() => e.show, () => {\n      t.value = e.show ?? !1;\n    });\n    function d() {\n      t.value = !1;\n    }\n    return r(\"initial\", {\n      show: t,\n      placement: u,\n      reference: a,\n      floating: c\n    }), () => {\n      if (!o.default)\n        return;\n      const f = {\n        placement: u.value,\n        close: d\n      }, [h] = D(o.default(f)).filter(I);\n      return L(\n        h,\n        {\n          as: e.as,\n          show: t.value\n        },\n        i,\n        s\n      );\n    };\n  }\n}, ke = {\n  as: n.as,\n  placement: n.placement,\n  strategy: n.strategy,\n  offset: n.offset,\n  shift: n.shift,\n  flip: {\n    ...n.flip,\n    default: !0\n  },\n  arrow: n.arrow,\n  autoPlacement: n.autoPlacement,\n  hide: n.hide,\n  autoUpdate: n.autoUpdate,\n  zIndex: n.zIndex,\n  transitionName: n.transitionName,\n  transitionType: n.transitionType,\n  enter: n.enter,\n  enterFrom: n.enterFrom,\n  enterTo: n.enterTo,\n  leave: n.leave,\n  leaveFrom: n.leaveFrom,\n  leaveTo: n.leaveTo,\n  originClass: n.originClass,\n  tailwindcssOriginClass: n.tailwindcssOriginClass,\n  transform: n.transform,\n  middleware: n.middleware\n}, Ze = {\n  name: \"FloatContextMenu\",\n  inheritAttrs: !1,\n  props: ke,\n  emits: [\"show\", \"hide\", \"update\"],\n  setup(e, { emit: r, slots: o, attrs: i }) {\n    function t({ show: a, reference: c, floating: s }) {\n      F(\"contextmenu\", (u) => {\n        u.preventDefault(), c.value = {\n          getBoundingClientRect() {\n            return {\n              width: 0,\n              height: 0,\n              x: u.clientX,\n              y: u.clientY,\n              top: u.clientY,\n              left: u.clientX,\n              right: u.clientX,\n              bottom: u.clientY\n            };\n          }\n        }, a.value = !0;\n      }), Ve(s, () => {\n        a.value = !1;\n      }, T(() => a.value));\n    }\n    return () => {\n      if (o.default)\n        return p(se, {\n          ...e,\n          ...i,\n          portal: !0,\n          onInitial: t,\n          onShow: () => r(\"show\"),\n          onHide: () => r(\"hide\"),\n          onUpdate: () => r(\"update\")\n        }, o.default);\n    };\n  }\n}, De = {\n  as: n.as,\n  placement: n.placement,\n  strategy: n.strategy,\n  offset: n.offset,\n  shift: n.shift,\n  flip: n.flip,\n  arrow: n.arrow,\n  autoPlacement: n.autoPlacement,\n  hide: n.hide,\n  autoUpdate: n.autoUpdate,\n  zIndex: n.zIndex,\n  transitionName: n.transitionName,\n  transitionType: n.transitionType,\n  enter: n.enter,\n  enterFrom: n.enterFrom,\n  enterTo: n.enterTo,\n  leave: n.leave,\n  leaveFrom: n.leaveFrom,\n  leaveTo: n.leaveTo,\n  originClass: n.originClass,\n  tailwindcssOriginClass: n.tailwindcssOriginClass,\n  transform: n.transform,\n  middleware: n.middleware,\n  globalHideCursor: {\n    type: Boolean,\n    default: !0\n  }\n}, et = {\n  name: \"FloatCursor\",\n  inheritAttrs: !1,\n  props: De,\n  emits: [\"show\", \"hide\", \"update\"],\n  setup({ globalHideCursor: e, ...r }, { emit: o, slots: i, attrs: t }) {\n    function a({ show: c, reference: s, floating: u }) {\n      function d() {\n        c.value = !0;\n      }\n      function f() {\n        c.value = !1;\n      }\n      function h(v) {\n        s.value = {\n          getBoundingClientRect() {\n            return {\n              width: 0,\n              height: 0,\n              x: v.clientX,\n              y: v.clientY,\n              top: v.clientY,\n              left: v.clientX,\n              right: v.clientX,\n              bottom: v.clientY\n            };\n          }\n        };\n      }\n      function m(v) {\n        d(), h(v);\n      }\n      function y(v) {\n        d(), h(v.touches[0]);\n      }\n      const l = K(u);\n      l && (J((v) => {\n        if (e && !l.getElementById(\"headlesui-float-cursor-style\")) {\n          const C = l.createElement(\"style\");\n          (l.head || l.getElementsByTagName(\"head\")[0]).appendChild(C), C.id = \"headlesui-float-cursor-style\", C.appendChild(l.createTextNode([\n            \"*, *::before, *::after {\",\n            \"  cursor: none !important;\",\n            \"}\",\n            \".headlesui-float-cursor-root {\",\n            \"  pointer-events: none !important;\",\n            \"}\"\n          ].join(`\n`))), v(() => {\n            var x;\n            return (x = l.getElementById(\"headlesui-float-cursor-style\")) == null ? void 0 : x.remove();\n          });\n        }\n      }, { flush: \"post\" }), \"ontouchstart\" in window || navigator.maxTouchPoints > 0 ? (F(\"touchstart\", y), F(\"touchend\", f), F(\"touchmove\", y)) : (F(\"mouseenter\", m), F(\"mouseleave\", f), F(\"mousemove\", m)));\n    }\n    return () => {\n      if (i.default)\n        return p(se, {\n          ...r,\n          ...t,\n          portal: !0,\n          class: \"headlesui-float-cursor-root\",\n          onInitial: a,\n          onShow: () => o(\"show\"),\n          onHide: () => o(\"hide\"),\n          onUpdate: () => o(\"update\")\n        }, i.default);\n    };\n  }\n};\nfunction tt(e) {\n  return (r, { slots: o }) => p(Ie, N(\n    e,\n    r\n  ), o);\n}\nconst Le = [\n  \"Float\",\n  \"FloatArrow\"\n];\nfunction nt(e = {}) {\n  const { prefix: r = \"\" } = e;\n  return {\n    type: \"component\",\n    resolve: (o) => {\n      if (o.startsWith(r)) {\n        const i = o.substring(r.length);\n        if (Le.includes(i))\n          return {\n            name: i,\n            from: \"@headlessui-float/vue\"\n          };\n      }\n    }\n  };\n}\nexport {\n  Ie as Float,\n  Qe as FloatArrow,\n  Ue as FloatArrowPropsValidators,\n  Ke as FloatContent,\n  q as FloatContentPropsValidators,\n  Ze as FloatContextMenu,\n  ke as FloatContextMenuPropsValidators,\n  et as FloatCursor,\n  De as FloatCursorPropsValidators,\n  n as FloatPropsValidators,\n  Je as FloatReference,\n  ze as FloatReferencePropsValidators,\n  se as FloatVirtual,\n  Me as FloatVirtualPropsValidators,\n  nt as HeadlessUiFloatResolver,\n  tt as createHighOrderFloatComponent,\n  L as renderFloatingElement,\n  ie as renderReferenceElement,\n  Be as tailwindcssOriginClassResolver,\n  Ge as tailwindcssOriginSafelist,\n  le as useFloat,\n  Ve as useOutsideClick\n};\n", "import { arrow as arrow$1, computePosition } from '@floating-ui/dom';\nexport * from '@floating-ui/dom';\nimport { unref, computed, ref, shallowRef, watch, getCurrentScope, onScopeDispose, shallowReadonly } from 'vue-demi';\n\nfunction unwrapElement(element) {\n  var _$el;\n  return (_$el = element == null ? void 0 : element.$el) != null ? _$el : element;\n}\n\n/**\n * Positions an inner element of the floating element such that it is centered to the reference element.\n * @param options The arrow options.\n * @see https://floating-ui.com/docs/arrow\n */\nfunction arrow(options) {\n  return {\n    name: 'arrow',\n    options,\n    fn(args) {\n      const element = unwrapElement(unref(options.element));\n      if (element == null) {\n        return {};\n      }\n      return arrow$1({\n        element,\n        padding: options.padding\n      }).fn(args);\n    }\n  };\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element next to a reference element when it is given a certain CSS positioning strategy.\n * @param reference The reference template ref.\n * @param floating The floating template ref.\n * @param options The floating options.\n * @see https://floating-ui.com/docs/vue\n */\nfunction useFloating(reference, floating, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const whileElementsMountedOption = options.whileElementsMounted;\n  const openOption = computed(() => {\n    var _unref;\n    return (_unref = unref(options.open)) != null ? _unref : true;\n  });\n  const middlewareOption = computed(() => unref(options.middleware));\n  const placementOption = computed(() => {\n    var _unref2;\n    return (_unref2 = unref(options.placement)) != null ? _unref2 : 'bottom';\n  });\n  const strategyOption = computed(() => {\n    var _unref3;\n    return (_unref3 = unref(options.strategy)) != null ? _unref3 : 'absolute';\n  });\n  const referenceElement = computed(() => unwrapElement(reference.value));\n  const floatingElement = computed(() => unwrapElement(floating.value));\n  const x = ref(null);\n  const y = ref(null);\n  const strategy = ref(strategyOption.value);\n  const placement = ref(placementOption.value);\n  const middlewareData = shallowRef({});\n  const isPositioned = ref(false);\n  let whileElementsMountedCleanup;\n  function update() {\n    if (referenceElement.value == null || floatingElement.value == null) {\n      return;\n    }\n    computePosition(referenceElement.value, floatingElement.value, {\n      middleware: middlewareOption.value,\n      placement: placementOption.value,\n      strategy: strategyOption.value\n    }).then(position => {\n      x.value = position.x;\n      y.value = position.y;\n      strategy.value = position.strategy;\n      placement.value = position.placement;\n      middlewareData.value = position.middlewareData;\n      isPositioned.value = true;\n    });\n  }\n  function cleanup() {\n    if (typeof whileElementsMountedCleanup === 'function') {\n      whileElementsMountedCleanup();\n      whileElementsMountedCleanup = undefined;\n    }\n  }\n  function attach() {\n    cleanup();\n    if (whileElementsMountedOption === undefined) {\n      update();\n      return;\n    }\n    if (referenceElement.value != null && floatingElement.value != null) {\n      whileElementsMountedCleanup = whileElementsMountedOption(referenceElement.value, floatingElement.value, update);\n      return;\n    }\n  }\n  function reset() {\n    if (!openOption.value) {\n      isPositioned.value = false;\n    }\n  }\n  watch([middlewareOption, placementOption, strategyOption], update, {\n    flush: 'sync'\n  });\n  watch([referenceElement, floatingElement], attach, {\n    flush: 'sync'\n  });\n  watch(openOption, reset, {\n    flush: 'sync'\n  });\n  if (getCurrentScope()) {\n    onScopeDispose(cleanup);\n  }\n  return {\n    x: shallowReadonly(x),\n    y: shallowReadonly(y),\n    strategy: shallowReadonly(strategy),\n    placement: shallowReadonly(placement),\n    middlewareData: shallowReadonly(middlewareData),\n    isPositioned: shallowReadonly(isPositioned),\n    update\n  };\n}\n\nexport { arrow, useFloating };\n", "import { rectToClientRect, computePosition as computePosition$1 } from '@floating-ui/core';\nexport { arrow, autoPlacement, detectOverflow, flip, hide, inline, limitShift, offset, shift, size } from '@floating-ui/core';\n\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\n\nfunction getComputedStyle$1(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n\nfunction isNode(value) {\n  return value instanceof getWindow(value).Node;\n}\nfunction getNodeName(node) {\n  return isNode(node) ? (node.nodeName || '').toLowerCase() : '';\n}\n\nlet uaString;\nfunction getUAString() {\n  if (uaString) {\n    return uaString;\n  }\n  const uaData = navigator.userAgentData;\n  if (uaData && Array.isArray(uaData.brands)) {\n    uaString = uaData.brands.map(item => item.brand + \"/\" + item.version).join(' ');\n    return uaString;\n  }\n  return navigator.userAgent;\n}\n\nfunction isHTMLElement(value) {\n  return value instanceof getWindow(value).HTMLElement;\n}\nfunction isElement(value) {\n  return value instanceof getWindow(value).Element;\n}\nfunction isShadowRoot(node) {\n  // Browsers without `ShadowRoot` support.\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle$1(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  // TODO: Try to use feature detection here instead.\n  const isFirefox = /firefox/i.test(getUAString());\n  const css = getComputedStyle$1(element);\n  const backdropFilter = css.backdropFilter || css.WebkitBackdropFilter;\n\n  // This is non-exhaustive but covers the most common CSS properties that\n  // create a containing block.\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return css.transform !== 'none' || css.perspective !== 'none' || (backdropFilter ? backdropFilter !== 'none' : false) || isFirefox && css.willChange === 'filter' || isFirefox && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective'].some(value => css.willChange.includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => {\n    // Add type check for old browsers.\n    const contain = css.contain;\n    return contain != null ? contain.includes(value) : false;\n  });\n}\n\n/**\n * Determines whether or not `.getBoundingClientRect()` is affected by visual\n * viewport offsets. In Safari, the `x`/`y` offsets are values relative to the\n * visual viewport, while in other engines, they are values relative to the\n * layout viewport.\n */\nfunction isClientRectVisualViewportBased() {\n  // TODO: Try to use feature detection here instead. Feature detection for\n  // this can fail in various ways, making the userAgent check the most\n  // reliable:\n  // \u2022 Always-visible scrollbar or not\n  // \u2022 Width of <html>\n\n  // Is Safari.\n  return /^((?!chrome|android).)*safari/i.test(getUAString());\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\n\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle$1(element);\n  let width = parseFloat(css.width);\n  let height = parseFloat(css.height);\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    fallback: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nconst FALLBACK_SCALE = {\n  x: 1,\n  y: 1\n};\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return FALLBACK_SCALE;\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    fallback\n  } = getCssDimensions(domElement);\n  let x = (fallback ? round(rect.width) : rect.width) / width;\n  let y = (fallback ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  var _win$visualViewport, _win$visualViewport2;\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = FALLBACK_SCALE;\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const win = domElement ? getWindow(domElement) : window;\n  const addVisualOffsets = isClientRectVisualViewportBased() && isFixedStrategy;\n  let x = (clientRect.left + (addVisualOffsets ? ((_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) || 0 : 0)) / scale.x;\n  let y = (clientRect.top + (addVisualOffsets ? ((_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) || 0 : 0)) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentIFrame = win.frameElement;\n    while (currentIFrame && offsetParent && offsetWin !== win) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      iframeRect.x += (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      iframeRect.y += (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += iframeRect.x;\n      y += iframeRect.y;\n      currentIFrame = getWindow(currentIFrame).frameElement;\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\nfunction getDocumentElement(node) {\n  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n}\n\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = {\n    x: 1,\n    y: 1\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle$1(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\n\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    // `getParentNode` will never return a `Document` due to the fallback\n    // check, so it's either the <html> or <body> element.\n    return parentNode.ownerDocument.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\n\nfunction getOverflowAncestors(node, list) {\n  var _node$ownerDocument;\n  if (list === void 0) {\n    list = [];\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor));\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isClientRectVisualViewportBased();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : {\n    x: 1,\n    y: 1\n  };\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const mutableRect = {\n      ...clippingAncestor\n    };\n    if (isClientRectVisualViewportBased()) {\n      var _win$visualViewport, _win$visualViewport2;\n      const win = getWindow(element);\n      mutableRect.x -= ((_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) || 0;\n      mutableRect.y -= ((_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) || 0;\n    }\n    rect = mutableRect;\n  }\n  return rectToClientRect(rect);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle$1(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle$1(currentNode);\n    const containingBlock = isContainingBlock(currentNode);\n    const shouldIgnoreCurrentNode = computedStyle.position === 'fixed';\n    if (shouldIgnoreCurrentNode) {\n      currentContainingBlockComputedStyle = null;\n    } else {\n      const shouldDropCurrentNode = elementIsFixed ? !containingBlock && !currentContainingBlockComputedStyle : !containingBlock && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position);\n      if (shouldDropCurrentNode) {\n        // Drop non-containing blocks.\n        result = result.filter(ancestor => ancestor !== currentNode);\n      } else {\n        // Record last containing block for next iteration.\n        currentContainingBlockComputedStyle = computedStyle;\n      }\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  return getCssDimensions(element);\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle$1(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  return element.offsetParent;\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = getParentNode(currentNode);\n    }\n  }\n  return null;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const window = getWindow(element);\n  if (!isHTMLElement(element)) {\n    return window;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const rect = getBoundingClientRect(element, true, strategy === 'fixed', offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nconst platform = {\n  getClippingRect,\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  isElement,\n  getDimensions,\n  getOffsetParent,\n  getDocumentElement,\n  getScale,\n  async getElementRects(_ref) {\n    let {\n      reference,\n      floating,\n      strategy\n    } = _ref;\n    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n    const getDimensionsFn = this.getDimensions;\n    return {\n      reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),\n      floating: {\n        x: 0,\n        y: 0,\n        ...(await getDimensionsFn(floating))\n      }\n    };\n  },\n  getClientRects: element => Array.from(element.getClientRects()),\n  isRTL: element => getComputedStyle$1(element).direction === 'rtl'\n};\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll: _ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = true,\n    animationFrame = false\n  } = options;\n  const ancestorScroll = _ancestorScroll && !animationFrame;\n  const ancestors = ancestorScroll || ancestorResize ? [...(isElement(reference) ? getOverflowAncestors(reference) : reference.contextElement ? getOverflowAncestors(reference.contextElement) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  let observer = null;\n  if (elementResize) {\n    let initialUpdate = true;\n    observer = new ResizeObserver(() => {\n      if (!initialUpdate) {\n        update();\n      }\n      initialUpdate = false;\n    });\n    isElement(reference) && !animationFrame && observer.observe(reference);\n    if (!isElement(reference) && reference.contextElement && !animationFrame) {\n      observer.observe(reference.contextElement);\n    }\n    observer.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _observer;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    (_observer = observer) == null ? void 0 : _observer.disconnect();\n    observer = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { autoUpdate, computePosition, getOverflowAncestors, platform };\n", "function getAlignment(placement) {\n  return placement.split('-')[1];\n}\n\nfunction getLengthFromAxis(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\n\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\n\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'x' : 'y';\n}\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  const commonAlign = reference[length] / 2 - floating[length] / 2;\n  const side = getSide(placement);\n  const isVertical = mainAxis === 'x';\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  if (process.env.NODE_ENV !== \"production\") {\n    if (platform == null) {\n      console.error(['Floating UI: `platform` property was not passed to config. If you', 'want to use Floating UI on the web, install @floating-ui/dom', 'instead of the /core package. Otherwise, you can create your own', '`platform`: https://floating-ui.com/docs/platform'].join(' '));\n    }\n    if (validMiddleware.filter(_ref => {\n      let {\n        name\n      } = _ref;\n      return name === 'autoPlacement' || name === 'flip';\n    }).length > 1) {\n      throw new Error(['Floating UI: duplicate `flip` and/or `autoPlacement` middleware', 'detected. This will lead to an infinite loop. Ensure only one of', 'either has been passed to the `middleware` array.'].join(' '));\n    }\n    if (!reference || !floating) {\n      console.error(['Floating UI: The reference and/or floating element was not defined', 'when `computePosition()` was called. Ensure that both elements have', 'been created and can be measured.'].join(' '));\n    }\n  }\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (process.env.NODE_ENV !== \"production\") {\n      if (resetCount > 50) {\n        console.warn(['Floating UI: The middleware lifecycle appears to be running in an', 'infinite loop. This is usually caused by a `reset` continually', 'being returned without a break condition.'].join(' '));\n      }\n    }\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n      continue;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\n\nfunction getSideObjectFromPadding(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\n\nfunction rectToClientRect(rect) {\n  return {\n    ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = options;\n  const paddingObject = getSideObjectFromPadding(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    ...rects.floating,\n    x,\n    y\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  if (process.env.NODE_ENV !== \"production\") ;\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\nconst min = Math.min;\nconst max = Math.max;\n\nfunction within(min$1, value, max$1) {\n  return max(min$1, min(value, max$1));\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = options || {};\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements\n    } = state;\n    if (element == null) {\n      if (process.env.NODE_ENV !== \"production\") {\n        console.warn('Floating UI: No `element` was passed to the `arrow` middleware.');\n      }\n      return {};\n    }\n    const paddingObject = getSideObjectFromPadding(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getMainAxisFromPlacement(placement);\n    const length = getLengthFromAxis(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min = paddingObject[minProp];\n    const max = clientSize - arrowDimensions[length] - paddingObject[maxProp];\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = within(min, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. This stops `shift()` from taking action, but can\n    // be worked around by calling it again after the `arrow()` if desired.\n    const shouldAddOffset = getAlignment(placement) != null && center != offset && rects.reference[length] / 2 - (center < min ? paddingObject[minProp] : paddingObject[maxProp]) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min ? min - center : max - center : 0;\n    return {\n      [axis]: coords[axis] - alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset\n      }\n    };\n  }\n});\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst allPlacements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-start\", side + \"-end\"), []);\n\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\n\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  let mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return {\n    main: mainAlignmentSide,\n    cross: getOppositePlacement(mainAlignmentSide)\n  };\n}\n\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = allPlacements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const placements = alignment !== undefined || allowedPlacements === allPlacements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const {\n        main,\n        cross\n      } = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[main], overflow[cross]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\n\nfunction getSideList(side, isStart, rtl) {\n  const lr = ['left', 'right'];\n  const rl = ['right', 'left'];\n  const tb = ['top', 'bottom'];\n  const bt = ['bottom', 'top'];\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const side = getSide(placement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const {\n          main,\n          cross\n        } = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[main], overflow[cross]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle.\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$map$so;\n                const placement = (_overflowsData$map$so = overflowsData.map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = options;\n      const {\n        rects\n      } = state;\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = options;\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getSideObjectFromPadding(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getMainAxisFromPlacement(placement) === 'x') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nasync function convertValueToCoords(state, value) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getMainAxisFromPlacement(placement) === 'x';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = typeof value === 'function' ? value(state) : value;\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (value) {\n  if (value === void 0) {\n    value = 0;\n  }\n  return {\n    name: 'offset',\n    options: value,\n    async fn(state) {\n      const {\n        x,\n        y\n      } = state;\n      const diffCoords = await convertValueToCoords(state, value);\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: diffCoords\n      };\n    }\n  };\n};\n\nfunction getCrossAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const mainAxis = getMainAxisFromPlacement(getSide(placement));\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = within(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = within(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const mainAxis = getMainAxisFromPlacement(placement);\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = typeof offset === 'function' ? offset(state) : offset;\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element \u2014\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = options;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const axis = getMainAxisFromPlacement(placement);\n      const isXAxis = axis === 'x';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const overflowAvailableHeight = height - overflow[heightSide];\n      const overflowAvailableWidth = width - overflow[widthSide];\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if (isXAxis) {\n        availableWidth = min(\n        // Maximum clipping viewport width\n        width - overflow.right - overflow.left, overflowAvailableWidth);\n      } else {\n        availableHeight = min(\n        // Maximum clipping viewport height\n        height - overflow.bottom - overflow.top, overflowAvailableHeight);\n      }\n      if (!state.middlewareData.shift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isXAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, rectToClientRect, shift, size };\n"],
  "mappings": "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",
  "names": []
}
