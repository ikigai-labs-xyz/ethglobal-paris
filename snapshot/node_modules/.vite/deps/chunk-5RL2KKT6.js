import {
  __commonJS,
  init_define_process_env
} from "./chunk-PLO4ZEQ3.js";

// node_modules/json-to-graphql-query/lib/types/EnumType.js
var require_EnumType = __commonJS({
  "node_modules/json-to-graphql-query/lib/types/EnumType.js"(exports) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", { value: true });
    var EnumType = function() {
      function EnumType2(value) {
        this.value = value;
      }
      return EnumType2;
    }();
    exports.EnumType = EnumType;
  }
});

// node_modules/json-to-graphql-query/lib/types/VariableType.js
var require_VariableType = __commonJS({
  "node_modules/json-to-graphql-query/lib/types/VariableType.js"(exports) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", { value: true });
    var VariableType = function() {
      function VariableType2(value) {
        this.value = value;
      }
      VariableType2.prototype.toJSON = function() {
        return "$" + this.value;
      };
      return VariableType2;
    }();
    exports.VariableType = VariableType;
  }
});

// node_modules/json-to-graphql-query/lib/jsonToGraphQLQuery.js
var require_jsonToGraphQLQuery = __commonJS({
  "node_modules/json-to-graphql-query/lib/jsonToGraphQLQuery.js"(exports) {
    "use strict";
    init_define_process_env();
    Object.defineProperty(exports, "__esModule", { value: true });
    var EnumType_1 = require_EnumType();
    var VariableType_1 = require_VariableType();
    exports.configFields = [
      "__args",
      "__alias",
      "__aliasFor",
      "__variables",
      "__directives",
      "__on",
      "__all_on",
      "__typeName",
      "__name"
    ];
    function stringify(obj_from_json) {
      if (obj_from_json instanceof EnumType_1.EnumType) {
        return obj_from_json.value;
      } else if (obj_from_json instanceof VariableType_1.VariableType) {
        return "$" + obj_from_json.value;
      } else if (typeof obj_from_json !== "object" || obj_from_json === null) {
        return JSON.stringify(obj_from_json);
      } else if (Array.isArray(obj_from_json)) {
        return "[" + obj_from_json.map(function(item) {
          return stringify(item);
        }).join(", ") + "]";
      }
      var props = Object.keys(obj_from_json).map(function(key) {
        return key + ": " + stringify(obj_from_json[key]);
      }).join(", ");
      return "{" + props + "}";
    }
    function buildArgs(argsObj) {
      var args = [];
      for (var argName in argsObj) {
        args.push(argName + ": " + stringify(argsObj[argName]));
      }
      return args.join(", ");
    }
    function buildVariables(varsObj) {
      var args = [];
      for (var varName in varsObj) {
        args.push("$" + varName + ": " + varsObj[varName]);
      }
      return args.join(", ");
    }
    function buildDirectives(dirsObj) {
      var directiveName = Object.keys(dirsObj)[0];
      var directiveValue = dirsObj[directiveName];
      if (typeof directiveValue === "boolean" || typeof directiveValue === "object" && Object.keys(directiveValue).length === 0) {
        return directiveName;
      } else if (typeof directiveValue === "object") {
        var args = [];
        for (var argName in directiveValue) {
          var argVal = stringify(directiveValue[argName]).replace(/"/g, "");
          args.push(argName + ": " + argVal);
        }
        return directiveName + "(" + args.join(", ") + ")";
      } else {
        throw new Error("Unsupported type for directive: " + typeof directiveValue + ". Types allowed: object, boolean.\n" + ("Offending object: " + JSON.stringify(dirsObj)));
      }
    }
    function getIndent(level) {
      return Array(level * 4 + 1).join(" ");
    }
    function filterNonConfigFields(fieldName, ignoreFields) {
      return exports.configFields.indexOf(fieldName) == -1 && ignoreFields.indexOf(fieldName) == -1;
    }
    function convertQuery(node, level, output, options) {
      Object.keys(node).filter(function(key) {
        return filterNonConfigFields(key, options.ignoreFields);
      }).forEach(function(key) {
        var value = node[key];
        if (typeof value === "object") {
          if (Array.isArray(value)) {
            value = value.find(function(item) {
              return item && typeof item === "object";
            });
            if (!value) {
              output.push(["" + key, level]);
              return;
            }
          }
          var fieldCount = Object.keys(value).filter(function(keyCount) {
            return filterNonConfigFields(keyCount, options.ignoreFields);
          }).length;
          var subFields = fieldCount > 0;
          var argsExist = typeof value.__args === "object" && Object.keys(value.__args).length > 0;
          var directivesExist = typeof value.__directives === "object";
          var fullFragmentsExist = value.__all_on instanceof Array;
          var partialFragmentsExist = typeof value.__on === "object";
          var token = "" + key;
          if (typeof value.__name === "string") {
            token = token + " " + value.__name;
          }
          if (typeof value.__aliasFor === "string") {
            token = token + ": " + value.__aliasFor;
          }
          if (typeof value.__variables === "object" && Object.keys(value.__variables).length > 0) {
            token = token + " (" + buildVariables(value.__variables) + ")";
          } else if (argsExist || directivesExist) {
            var argsStr = "";
            var dirsStr = "";
            if (directivesExist) {
              dirsStr = Object.entries(value.__directives).map(function(item) {
                var _a;
                return "@" + buildDirectives((_a = {}, _a[item[0]] = item[1], _a));
              }).join(" ");
            }
            if (argsExist) {
              argsStr = "(" + buildArgs(value.__args) + ")";
            }
            var spacer = directivesExist && argsExist ? " " : "";
            token = token + " " + argsStr + spacer + dirsStr;
          }
          output.push([token + (subFields || partialFragmentsExist || fullFragmentsExist ? " {" : ""), level]);
          convertQuery(value, level + 1, output, options);
          if (fullFragmentsExist) {
            value.__all_on.forEach(function(fullFragment) {
              output.push(["..." + fullFragment, level + 1]);
            });
          }
          if (partialFragmentsExist) {
            var inlineFragments = value.__on instanceof Array ? value.__on : [value.__on];
            inlineFragments.forEach(function(inlineFragment) {
              var name = inlineFragment.__typeName;
              output.push(["... on " + name + " {", level + 1]);
              convertQuery(inlineFragment, level + 2, output, options);
              output.push(["}", level + 1]);
            });
          }
          if (subFields || partialFragmentsExist || fullFragmentsExist) {
            output.push(["}", level]);
          }
        } else if (options.includeFalsyKeys === true || value) {
          output.push(["" + key, level]);
        }
      });
    }
    function jsonToGraphQLQuery(query, options) {
      if (options === void 0) {
        options = {};
      }
      if (!query || typeof query != "object") {
        throw new Error("query object not specified");
      }
      if (Object.keys(query).length == 0) {
        throw new Error("query object has no data");
      }
      if (!(options.ignoreFields instanceof Array)) {
        options.ignoreFields = [];
      }
      var queryLines = [];
      convertQuery(query, 0, queryLines, options);
      var output = "";
      queryLines.forEach(function(_a) {
        var line = _a[0], level = _a[1];
        if (options.pretty) {
          if (output) {
            output += "\n";
          }
          output += getIndent(level) + line;
        } else {
          if (output) {
            output += " ";
          }
          output += line;
        }
      });
      return output;
    }
    exports.jsonToGraphQLQuery = jsonToGraphQLQuery;
  }
});

// node_modules/json-to-graphql-query/lib/index.js
var require_lib = __commonJS({
  "node_modules/json-to-graphql-query/lib/index.js"(exports) {
    "use strict";
    init_define_process_env();
    function __export(m) {
      for (var p in m)
        if (!exports.hasOwnProperty(p))
          exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(require_jsonToGraphQLQuery());
    var EnumType_1 = require_EnumType();
    exports.EnumType = EnumType_1.EnumType;
    var VariableType_1 = require_VariableType();
    exports.VariableType = VariableType_1.VariableType;
  }
});

// node_modules/lodash.set/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.set/index.js"(exports, module) {
    init_define_process_env();
    var FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var symbolTag = "[object Symbol]";
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    var reLeadingDot = /^\./;
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reEscapeChar = /\\(\\)?/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var Symbol = root.Symbol;
    var splice = arrayProto.splice;
    var Map = getNative(root, "Map");
    var nativeCreate = getNative(Object, "create");
    var symbolProto = Symbol ? Symbol.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        object[key] = value;
      }
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseSet(object, path, value, customizer) {
      if (!isObject(object)) {
        return object;
      }
      path = isKey(path, object) ? [path] : castPath(path);
      var index = -1, length = path.length, lastIndex = length - 1, nested = object;
      while (nested != null && ++index < length) {
        var key = toKey(path[index]), newValue = value;
        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : void 0;
          if (newValue === void 0) {
            newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function castPath(value) {
      return isArray(value) ? value : stringToPath(value);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    var stringToPath = memoize(function(string) {
      string = toString(string);
      var result = [];
      if (reLeadingDot.test(string)) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, string2) {
        result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArray = Array.isArray;
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function set(object, path, value) {
      return object == null ? object : baseSet(object, path, value);
    }
    module.exports = set;
  }
});

export {
  require_lib,
  require_lodash
};
//# sourceMappingURL=chunk-5RL2KKT6.js.map
