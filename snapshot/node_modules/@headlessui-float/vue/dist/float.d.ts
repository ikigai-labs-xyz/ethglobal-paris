import type { ComputedRef, FunctionalComponent, PropType, Ref, SetupContext, VNode } from 'vue';
import type { DetectOverflowOptions, FloatingElement, Middleware, Placement, ReferenceElement, Strategy, VirtualElement } from '@floating-ui/dom';
import type { Options as OffsetOptions } from '@floating-ui/core/src/middleware/offset';
import type { Options as ShiftOptions } from '@floating-ui/core/src/middleware/shift';
import type { Options as FlipOptions } from '@floating-ui/core/src/middleware/flip';
import type { Options as AutoPlacementOptions } from '@floating-ui/core/src/middleware/autoPlacement';
import type { Options as HideOptions } from '@floating-ui/core/src/middleware/hide';
import type { Options as AutoUpdateOptions } from '@floating-ui/dom/src/autoUpdate';
import { type OriginClassResolver } from './origin-class-resolvers';
interface ReferenceState {
    referenceRef: Ref<ReferenceElement | null>;
    placement: Readonly<Ref<Placement>>;
}
interface FloatingState {
    floatingRef: Ref<FloatingElement | null>;
    props: FloatProps;
    mounted: Ref<boolean>;
    show: Ref<boolean>;
    x: Readonly<Ref<number | null>>;
    y: Readonly<Ref<number | null>>;
    placement: Readonly<Ref<Placement>>;
    strategy: Readonly<Ref<Strategy>>;
    referenceElWidth: Ref<number | null>;
    updateFloating: () => void;
}
interface ArrowState {
    ref: Ref<HTMLElement | null>;
    placement: Ref<Placement>;
    x: Ref<number | undefined>;
    y: Ref<number | undefined>;
}
export interface FloatProps {
    as?: string | FunctionalComponent;
    floatingAs?: string | FunctionalComponent;
    show?: boolean;
    placement?: Placement;
    strategy?: Strategy;
    offset?: OffsetOptions;
    shift?: boolean | number | Partial<ShiftOptions & DetectOverflowOptions>;
    flip?: boolean | number | Partial<FlipOptions & DetectOverflowOptions>;
    arrow?: boolean | number;
    autoPlacement?: boolean | Partial<AutoPlacementOptions & DetectOverflowOptions>;
    hide?: boolean | Partial<HideOptions & DetectOverflowOptions>;
    autoUpdate?: boolean | Partial<AutoUpdateOptions>;
    zIndex?: number | string;
    transitionName?: string;
    transitionType?: 'transition' | 'animation';
    enter?: string;
    enterFrom?: string;
    enterTo?: string;
    leave?: string;
    leaveFrom?: string;
    leaveTo?: string;
    originClass?: string | OriginClassResolver;
    tailwindcssOriginClass?: boolean;
    portal?: boolean;
    transform?: boolean;
    adaptiveWidth?: boolean;
    composable?: boolean;
    dialog?: boolean;
    middleware?: Middleware[] | ((refs: {
        referenceEl: ComputedRef<ReferenceElement | null>;
        floatingEl: ComputedRef<HTMLElement | null>;
    }) => Middleware[]);
    onShow?: () => any;
    onHide?: () => any;
    onUpdate?: () => any;
}
export declare const FloatPropsValidators: {
    as: {
        type: PropType<string | FunctionalComponent<{}, {}>>;
        default: string;
    };
    floatingAs: {
        type: PropType<string | FunctionalComponent<{}, {}>>;
        default: string;
    };
    show: {
        type: BooleanConstructor;
        default: null;
    };
    placement: {
        type: PropType<Placement>;
        default: string;
    };
    strategy: {
        type: PropType<Strategy>;
        default: string;
    };
    offset: PropType<OffsetOptions>;
    shift: {
        type: PropType<number | boolean | Partial<ShiftOptions & {
            rootBoundary: import("@floating-ui/vue").RootBoundary;
            elementContext: import("@floating-ui/vue").ElementContext;
            altBoundary: boolean;
            padding: import("@floating-ui/vue").Padding;
            boundary: import("@floating-ui/vue").Boundary;
        }>>;
        default: boolean;
    };
    flip: {
        type: PropType<number | boolean | Partial<FlipOptions & {
            rootBoundary: import("@floating-ui/vue").RootBoundary;
            elementContext: import("@floating-ui/vue").ElementContext;
            altBoundary: boolean;
            padding: import("@floating-ui/vue").Padding;
            boundary: import("@floating-ui/vue").Boundary;
        }>>;
        default: boolean;
    };
    arrow: {
        type: (NumberConstructor | BooleanConstructor)[];
        default: boolean;
    };
    autoPlacement: {
        type: PropType<boolean | Partial<AutoPlacementOptions & {
            rootBoundary: import("@floating-ui/vue").RootBoundary;
            elementContext: import("@floating-ui/vue").ElementContext;
            altBoundary: boolean;
            padding: import("@floating-ui/vue").Padding;
            boundary: import("@floating-ui/vue").Boundary;
        }>>;
        default: boolean;
    };
    hide: {
        type: PropType<boolean | Partial<HideOptions & {
            rootBoundary: import("@floating-ui/vue").RootBoundary;
            elementContext: import("@floating-ui/vue").ElementContext;
            altBoundary: boolean;
            padding: import("@floating-ui/vue").Padding;
            boundary: import("@floating-ui/vue").Boundary;
        }>>;
        default: boolean;
    };
    autoUpdate: {
        type: PropType<boolean | Partial<AutoUpdateOptions>>;
        default: boolean;
    };
    zIndex: {
        type: (NumberConstructor | StringConstructor)[];
        default: number;
    };
    transitionName: StringConstructor;
    transitionType: PropType<"transition" | "animation">;
    enter: StringConstructor;
    enterFrom: StringConstructor;
    enterTo: StringConstructor;
    leave: StringConstructor;
    leaveFrom: StringConstructor;
    leaveTo: StringConstructor;
    originClass: PropType<string | OriginClassResolver>;
    tailwindcssOriginClass: {
        type: BooleanConstructor;
        default: boolean;
    };
    portal: {
        type: BooleanConstructor;
        default: boolean;
    };
    transform: {
        type: BooleanConstructor;
        default: boolean;
    };
    adaptiveWidth: {
        type: BooleanConstructor;
        default: boolean;
    };
    composable: {
        type: BooleanConstructor;
        default: boolean;
    };
    dialog: {
        type: BooleanConstructor;
        default: boolean;
    };
    middleware: {
        type: PropType<{
            options?: any;
            name: string;
            fn: (state: {
                x: number;
                y: number;
                strategy: Strategy;
                initialPlacement: Placement;
                placement: Placement;
                middlewareData: import("@floating-ui/vue").MiddlewareData;
                rects: import("@floating-ui/vue").ElementRects;
                platform: import("@floating-ui/core").Platform;
                elements: import("@floating-ui/vue").Elements;
            }) => import("@floating-ui/vue").MiddlewareReturn | Promise<import("@floating-ui/vue").MiddlewareReturn>;
        }[] | ((refs: {
            referenceEl: ComputedRef<ReferenceElement | null>;
            floatingEl: ComputedRef<FloatingElement | null>;
        }) => Middleware[])>;
        default: () => never[];
    };
};
export interface FloatSlotProps {
    placement: Placement;
}
export type RenderReferenceElementProps = FloatReferenceProps & Required<Pick<FloatReferenceProps, 'as'>>;
export declare function renderReferenceElement(referenceNode: VNode, componentProps: RenderReferenceElementProps, attrs: SetupContext['attrs'], context: ReferenceState): VNode<import("vue").RendererNode, import("vue").RendererElement, {
    [key: string]: any;
}>;
export type RenderFloatingElementProps = FloatContentProps & Required<Pick<FloatContentProps, 'as'>> & {
    show?: boolean | null;
};
export declare function renderFloatingElement(floatingNode: VNode, componentProps: RenderFloatingElementProps, attrs: SetupContext['attrs'], context: FloatingState): VNode<import("vue").RendererNode, import("vue").RendererElement, {
    [key: string]: any;
}>;
export declare function useFloat<T extends ReferenceElement>(show: Ref<boolean>, reference: Ref<T | null>, floating: Ref<FloatingElement | null>, props: FloatProps, emit: (event: 'show' | 'hide' | 'update', ...args: any[]) => void): {
    referenceApi: ReferenceState;
    floatingApi: FloatingState;
    arrowApi: ArrowState;
    x: Readonly<Ref<number | null>>;
    y: Readonly<Ref<number | null>>;
    placement: Readonly<Ref<Placement>>;
    strategy: Readonly<Ref<Strategy>>;
    referenceEl: ComputedRef<T | null>;
    floatingEl: ComputedRef<HTMLElement | null>;
    middlewareData: Readonly<Ref<import("@floating-ui/vue").MiddlewareData>>;
    update: () => void;
};
export declare const Float: new () => {
    $props: FloatProps;
    $slots: {
        default(props: FloatSlotProps): any;
    };
};
export interface FloatReferenceProps extends Pick<FloatProps, 'as'> {
}
export declare const FloatReferencePropsValidators: {
    as: {
        type: PropType<string | FunctionalComponent<{}, {}>>;
        default: string;
    };
};
export interface FloatReferenceSlotProps {
    placement: Placement;
}
export declare const FloatReference: new () => {
    $props: FloatReferenceProps;
    $slots: {
        default(props: FloatReferenceSlotProps): any;
    };
};
export interface FloatContentProps extends Pick<FloatProps, 'as' | 'transitionName' | 'transitionType' | 'enter' | 'enterFrom' | 'enterTo' | 'leave' | 'leaveFrom' | 'leaveTo' | 'originClass' | 'tailwindcssOriginClass'> {
    transitionChild?: boolean;
}
export declare const FloatContentPropsValidators: {
    as: {
        type: PropType<string | FunctionalComponent<{}, {}>>;
        default: string;
    };
    transitionName: StringConstructor;
    transitionType: PropType<"transition" | "animation">;
    enter: StringConstructor;
    enterFrom: StringConstructor;
    enterTo: StringConstructor;
    leave: StringConstructor;
    leaveFrom: StringConstructor;
    leaveTo: StringConstructor;
    originClass: PropType<string | OriginClassResolver>;
    tailwindcssOriginClass: {
        type: BooleanConstructor;
        default: boolean;
    };
    transitionChild: {
        type: BooleanConstructor;
        default: boolean;
    };
};
export interface FloatContentSlotProps {
    placement: Placement;
}
export declare const FloatContent: new () => {
    $props: FloatContentProps;
    $slots: {
        default(props: FloatContentSlotProps): any;
    };
};
export interface FloatArrowProps extends Pick<FloatProps, 'as'> {
    offset?: number;
}
export declare const FloatArrowPropsValidators: {
    as: {
        default: string;
        type: PropType<string | FunctionalComponent<{}, {}>>;
    };
    offset: {
        type: NumberConstructor;
        default: number;
    };
};
export interface FloatArrowSlotProps {
    placement: Placement;
}
export declare const FloatArrow: new () => {
    $props: FloatArrowProps;
    $slots: {
        default(props: FloatArrowSlotProps): any;
    };
};
export interface FloatVirtualProps<FloatingElement = HTMLElement> extends Pick<FloatProps, 'as' | 'show' | 'placement' | 'strategy' | 'offset' | 'shift' | 'flip' | 'arrow' | 'autoPlacement' | 'hide' | 'autoUpdate' | 'zIndex' | 'transitionName' | 'transitionType' | 'enter' | 'enterFrom' | 'enterTo' | 'leave' | 'leaveFrom' | 'leaveTo' | 'originClass' | 'tailwindcssOriginClass' | 'portal' | 'transform' | 'middleware' | 'onShow' | 'onHide' | 'onUpdate'> {
    onInitial?: (props: FloatVirtualInitialProps<FloatingElement>) => any;
}
export declare const FloatVirtualPropsValidators: {
    as: {
        type: PropType<string | FunctionalComponent<{}, {}>>;
        default: string;
    };
    show: {
        type: BooleanConstructor;
        default: null;
    };
    placement: {
        type: PropType<Placement>;
        default: string;
    };
    strategy: {
        type: PropType<Strategy>;
        default: string;
    };
    offset: PropType<OffsetOptions>;
    shift: {
        type: PropType<number | boolean | Partial<ShiftOptions & {
            rootBoundary: import("@floating-ui/vue").RootBoundary;
            elementContext: import("@floating-ui/vue").ElementContext;
            altBoundary: boolean;
            padding: import("@floating-ui/vue").Padding;
            boundary: import("@floating-ui/vue").Boundary;
        }>>;
        default: boolean;
    };
    flip: {
        type: PropType<number | boolean | Partial<FlipOptions & {
            rootBoundary: import("@floating-ui/vue").RootBoundary;
            elementContext: import("@floating-ui/vue").ElementContext;
            altBoundary: boolean;
            padding: import("@floating-ui/vue").Padding;
            boundary: import("@floating-ui/vue").Boundary;
        }>>;
        default: boolean;
    };
    arrow: {
        type: (NumberConstructor | BooleanConstructor)[];
        default: boolean;
    };
    autoPlacement: {
        type: PropType<boolean | Partial<AutoPlacementOptions & {
            rootBoundary: import("@floating-ui/vue").RootBoundary;
            elementContext: import("@floating-ui/vue").ElementContext;
            altBoundary: boolean;
            padding: import("@floating-ui/vue").Padding;
            boundary: import("@floating-ui/vue").Boundary;
        }>>;
        default: boolean;
    };
    hide: {
        type: PropType<boolean | Partial<HideOptions & {
            rootBoundary: import("@floating-ui/vue").RootBoundary;
            elementContext: import("@floating-ui/vue").ElementContext;
            altBoundary: boolean;
            padding: import("@floating-ui/vue").Padding;
            boundary: import("@floating-ui/vue").Boundary;
        }>>;
        default: boolean;
    };
    autoUpdate: {
        type: PropType<boolean | Partial<AutoUpdateOptions>>;
        default: boolean;
    };
    zIndex: {
        type: (NumberConstructor | StringConstructor)[];
        default: number;
    };
    transitionName: StringConstructor;
    transitionType: PropType<"transition" | "animation">;
    enter: StringConstructor;
    enterFrom: StringConstructor;
    enterTo: StringConstructor;
    leave: StringConstructor;
    leaveFrom: StringConstructor;
    leaveTo: StringConstructor;
    originClass: PropType<string | OriginClassResolver>;
    tailwindcssOriginClass: {
        type: BooleanConstructor;
        default: boolean;
    };
    portal: {
        type: BooleanConstructor;
        default: boolean;
    };
    transform: {
        type: BooleanConstructor;
        default: boolean;
    };
    middleware: {
        type: PropType<{
            options?: any;
            name: string;
            fn: (state: {
                x: number;
                y: number;
                strategy: Strategy;
                initialPlacement: Placement;
                placement: Placement;
                middlewareData: import("@floating-ui/vue").MiddlewareData;
                rects: import("@floating-ui/vue").ElementRects;
                platform: import("@floating-ui/core").Platform;
                elements: import("@floating-ui/vue").Elements;
            }) => import("@floating-ui/vue").MiddlewareReturn | Promise<import("@floating-ui/vue").MiddlewareReturn>;
        }[] | ((refs: {
            referenceEl: ComputedRef<ReferenceElement | null>;
            floatingEl: ComputedRef<FloatingElement | null>;
        }) => Middleware[])>;
        default: () => never[];
    };
};
export interface FloatVirtualSlotProps {
    placement: Placement;
    close: () => void;
}
export interface FloatVirtualInitialProps<FloatingElement = HTMLElement> {
    show: Ref<boolean>;
    placement: Readonly<Ref<Placement>>;
    reference: Ref<VirtualElement>;
    floating: Ref<FloatingElement | null>;
}
export declare const FloatVirtual: new () => {
    $props: FloatVirtualProps<any>;
    $slots: {
        default(props: FloatVirtualSlotProps): any;
    };
};
export interface FloatContextMenuProps extends Omit<FloatVirtualProps, 'show' | 'portal'> {
}
export declare const FloatContextMenuPropsValidators: {
    as: {
        type: PropType<string | FunctionalComponent<{}, {}>>;
        default: string;
    };
    placement: {
        type: PropType<Placement>;
        default: string;
    };
    strategy: {
        type: PropType<Strategy>;
        default: string;
    };
    offset: PropType<OffsetOptions>;
    shift: {
        type: PropType<number | boolean | Partial<ShiftOptions & {
            rootBoundary: import("@floating-ui/vue").RootBoundary;
            elementContext: import("@floating-ui/vue").ElementContext;
            altBoundary: boolean;
            padding: import("@floating-ui/vue").Padding;
            boundary: import("@floating-ui/vue").Boundary;
        }>>;
        default: boolean;
    };
    flip: {
        default: boolean;
        type: PropType<number | boolean | Partial<FlipOptions & {
            rootBoundary: import("@floating-ui/vue").RootBoundary;
            elementContext: import("@floating-ui/vue").ElementContext;
            altBoundary: boolean;
            padding: import("@floating-ui/vue").Padding;
            boundary: import("@floating-ui/vue").Boundary;
        }>>;
    };
    arrow: {
        type: (NumberConstructor | BooleanConstructor)[];
        default: boolean;
    };
    autoPlacement: {
        type: PropType<boolean | Partial<AutoPlacementOptions & {
            rootBoundary: import("@floating-ui/vue").RootBoundary;
            elementContext: import("@floating-ui/vue").ElementContext;
            altBoundary: boolean;
            padding: import("@floating-ui/vue").Padding;
            boundary: import("@floating-ui/vue").Boundary;
        }>>;
        default: boolean;
    };
    hide: {
        type: PropType<boolean | Partial<HideOptions & {
            rootBoundary: import("@floating-ui/vue").RootBoundary;
            elementContext: import("@floating-ui/vue").ElementContext;
            altBoundary: boolean;
            padding: import("@floating-ui/vue").Padding;
            boundary: import("@floating-ui/vue").Boundary;
        }>>;
        default: boolean;
    };
    autoUpdate: {
        type: PropType<boolean | Partial<AutoUpdateOptions>>;
        default: boolean;
    };
    zIndex: {
        type: (NumberConstructor | StringConstructor)[];
        default: number;
    };
    transitionName: StringConstructor;
    transitionType: PropType<"transition" | "animation">;
    enter: StringConstructor;
    enterFrom: StringConstructor;
    enterTo: StringConstructor;
    leave: StringConstructor;
    leaveFrom: StringConstructor;
    leaveTo: StringConstructor;
    originClass: PropType<string | OriginClassResolver>;
    tailwindcssOriginClass: {
        type: BooleanConstructor;
        default: boolean;
    };
    transform: {
        type: BooleanConstructor;
        default: boolean;
    };
    middleware: {
        type: PropType<{
            options?: any;
            name: string;
            fn: (state: {
                x: number;
                y: number;
                strategy: Strategy;
                initialPlacement: Placement;
                placement: Placement;
                middlewareData: import("@floating-ui/vue").MiddlewareData;
                rects: import("@floating-ui/vue").ElementRects;
                platform: import("@floating-ui/core").Platform;
                elements: import("@floating-ui/vue").Elements;
            }) => import("@floating-ui/vue").MiddlewareReturn | Promise<import("@floating-ui/vue").MiddlewareReturn>;
        }[] | ((refs: {
            referenceEl: ComputedRef<ReferenceElement | null>;
            floatingEl: ComputedRef<FloatingElement | null>;
        }) => Middleware[])>;
        default: () => never[];
    };
};
export declare const FloatContextMenu: new () => {
    $props: FloatContextMenuProps;
    $slots: {
        default(props: FloatVirtualSlotProps): any;
    };
};
export interface FloatCursorProps extends Omit<FloatVirtualProps, 'show' | 'portal'> {
    globalHideCursor?: boolean;
}
export declare const FloatCursorPropsValidators: {
    as: {
        type: PropType<string | FunctionalComponent<{}, {}>>;
        default: string;
    };
    placement: {
        type: PropType<Placement>;
        default: string;
    };
    strategy: {
        type: PropType<Strategy>;
        default: string;
    };
    offset: PropType<OffsetOptions>;
    shift: {
        type: PropType<number | boolean | Partial<ShiftOptions & {
            rootBoundary: import("@floating-ui/vue").RootBoundary;
            elementContext: import("@floating-ui/vue").ElementContext;
            altBoundary: boolean;
            padding: import("@floating-ui/vue").Padding;
            boundary: import("@floating-ui/vue").Boundary;
        }>>;
        default: boolean;
    };
    flip: {
        type: PropType<number | boolean | Partial<FlipOptions & {
            rootBoundary: import("@floating-ui/vue").RootBoundary;
            elementContext: import("@floating-ui/vue").ElementContext;
            altBoundary: boolean;
            padding: import("@floating-ui/vue").Padding;
            boundary: import("@floating-ui/vue").Boundary;
        }>>;
        default: boolean;
    };
    arrow: {
        type: (NumberConstructor | BooleanConstructor)[];
        default: boolean;
    };
    autoPlacement: {
        type: PropType<boolean | Partial<AutoPlacementOptions & {
            rootBoundary: import("@floating-ui/vue").RootBoundary;
            elementContext: import("@floating-ui/vue").ElementContext;
            altBoundary: boolean;
            padding: import("@floating-ui/vue").Padding;
            boundary: import("@floating-ui/vue").Boundary;
        }>>;
        default: boolean;
    };
    hide: {
        type: PropType<boolean | Partial<HideOptions & {
            rootBoundary: import("@floating-ui/vue").RootBoundary;
            elementContext: import("@floating-ui/vue").ElementContext;
            altBoundary: boolean;
            padding: import("@floating-ui/vue").Padding;
            boundary: import("@floating-ui/vue").Boundary;
        }>>;
        default: boolean;
    };
    autoUpdate: {
        type: PropType<boolean | Partial<AutoUpdateOptions>>;
        default: boolean;
    };
    zIndex: {
        type: (NumberConstructor | StringConstructor)[];
        default: number;
    };
    transitionName: StringConstructor;
    transitionType: PropType<"transition" | "animation">;
    enter: StringConstructor;
    enterFrom: StringConstructor;
    enterTo: StringConstructor;
    leave: StringConstructor;
    leaveFrom: StringConstructor;
    leaveTo: StringConstructor;
    originClass: PropType<string | OriginClassResolver>;
    tailwindcssOriginClass: {
        type: BooleanConstructor;
        default: boolean;
    };
    transform: {
        type: BooleanConstructor;
        default: boolean;
    };
    middleware: {
        type: PropType<{
            options?: any;
            name: string;
            fn: (state: {
                x: number;
                y: number;
                strategy: Strategy;
                initialPlacement: Placement;
                placement: Placement;
                middlewareData: import("@floating-ui/vue").MiddlewareData;
                rects: import("@floating-ui/vue").ElementRects;
                platform: import("@floating-ui/core").Platform;
                elements: import("@floating-ui/vue").Elements;
            }) => import("@floating-ui/vue").MiddlewareReturn | Promise<import("@floating-ui/vue").MiddlewareReturn>;
        }[] | ((refs: {
            referenceEl: ComputedRef<ReferenceElement | null>;
            floatingEl: ComputedRef<FloatingElement | null>;
        }) => Middleware[])>;
        default: () => never[];
    };
    globalHideCursor: {
        type: BooleanConstructor;
        default: boolean;
    };
};
export declare const FloatCursor: new () => {
    $props: FloatCursorProps;
    $slots: {
        default(props: FloatVirtualSlotProps): any;
    };
};
export {};
