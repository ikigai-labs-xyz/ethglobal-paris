var ce = Object.defineProperty;
var de = (e, r, o) => r in e ? ce(e, r, { enumerable: !0, configurable: !0, writable: !0, value: o }) : e[r] = o;
var H = (e, r, o) => (de(e, typeof r != "symbol" ? r + "" : r, o), o);
import { ref as g, Fragment as me, unref as ve, watch as O, onMounted as G, onBeforeUnmount as he, computed as T, watchEffect as J, mergeProps as N, cloneVNode as M, h as p, toRef as X, shallowRef as ge, nextTick as pe, provide as U, inject as k, createCommentVNode as Y, Transition as ye } from "vue";
import { Portal as we, TransitionChild as be } from "@headlessui/vue";
import { arrow as Fe, useFloating as Ce } from "@floating-ui/vue";
import { offset as xe, flip as Te, shift as Ee, autoPlacement as Pe, hide as Ae, autoUpdate as Se } from "@floating-ui/dom";
function j(e) {
  if (e == null || e.value == null)
    return null;
  const r = e.value.$el ?? e.value;
  return r.$el ? j(g(r)) : r;
}
class Oe {
  constructor() {
    H(this, "current", this.detect());
  }
  set(r) {
    this.current !== r && (this.current = r);
  }
  reset() {
    this.set(this.detect());
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window > "u" || typeof document > "u" ? "server" : "client";
  }
}
const z = new Oe();
function D(e) {
  return e.reduce((r, o) => o.type === me ? r.concat(D(o.children)) : r.concat(o), []);
}
function I(e) {
  return e == null ? !1 : typeof e.type == "string" || typeof e.type == "object" || typeof e.type == "function";
}
function W(e) {
  return e = ve(e), e && (e == null ? void 0 : e.nodeType) !== Node.COMMENT_NODE;
}
function K(e) {
  if (z.isServer)
    return null;
  if (e instanceof Node)
    return e.ownerDocument;
  if (Object.prototype.hasOwnProperty.call(e, "value")) {
    const r = j(e);
    if (r)
      return r.ownerDocument;
  }
  return document;
}
function Ne(e, r, o, i, t) {
  O([
    () => t.offset,
    () => t.flip,
    () => t.shift,
    () => t.autoPlacement,
    () => t.arrow,
    () => t.hide,
    () => t.middleware
  ], () => {
    const a = [];
    (typeof t.offset == "number" || typeof t.offset == "object" || typeof t.offset == "function") && a.push(xe(t.offset)), (t.flip === !0 || typeof t.flip == "number" || typeof t.flip == "object") && a.push(Te({
      padding: typeof t.flip == "number" ? t.flip : void 0,
      ...typeof t.flip == "object" ? t.flip : {}
    })), (t.shift === !0 || typeof t.shift == "number" || typeof t.shift == "object") && a.push(Ee({
      padding: typeof t.shift == "number" ? t.shift : void 0,
      ...typeof t.shift == "object" ? t.shift : {}
    })), (t.autoPlacement === !0 || typeof t.autoPlacement == "object") && a.push(Pe(
      typeof t.autoPlacement == "object" ? t.autoPlacement : void 0
    )), (t.arrow === !0 || typeof t.arrow == "number") && a.push(Fe({
      element: i,
      padding: t.arrow === !0 ? 0 : t.arrow
    })), a.push(...typeof t.middleware == "function" ? t.middleware({
      referenceEl: r,
      floatingEl: o
    }) : t.middleware || []), (t.hide === !0 || typeof t.hide == "object") && a.push(Ae(
      typeof t.hide == "object" ? t.hide : void 0
    )), e.value = a;
  }, { immediate: !0 });
}
function Re(e, r, o) {
  let i = () => {
  };
  G(() => {
    if (e && z.isClient && typeof ResizeObserver < "u" && r.value && r.value instanceof Element) {
      const t = new ResizeObserver(([a]) => {
        o.value = a.borderBoxSize.reduce((c, { inlineSize: s }) => c + s, 0);
      });
      t.observe(r.value), i = () => {
        t.disconnect(), o.value = null;
      };
    }
  }), he(() => {
    i();
  });
}
const Ge = [
  "origin-bottom",
  "origin-top",
  "origin-right",
  "origin-left",
  "origin-bottom-left",
  "origin-bottom-right",
  "origin-top-left",
  "origin-top-right"
], Be = (e) => {
  switch (e) {
    case "top":
      return "origin-bottom";
    case "bottom":
      return "origin-top";
    case "left":
      return "origin-right";
    case "right":
      return "origin-left";
    case "top-start":
    case "right-end":
      return "origin-bottom-left";
    case "top-end":
    case "left-end":
      return "origin-bottom-right";
    case "right-start":
    case "bottom-start":
      return "origin-top-left";
    case "left-start":
    case "bottom-end":
      return "origin-top-right";
    default:
      return "";
  }
};
function je(e, r) {
  const o = T(() => {
    if (typeof e.originClass == "function")
      return e.originClass(r.value);
    if (typeof e.originClass == "string")
      return e.originClass;
    if (e.tailwindcssOriginClass)
      return Be(r.value);
  }), i = T(
    () => e.enter || o.value ? `${e.enter || ""} ${o.value || ""}` : void 0
  ), t = T(
    () => e.leave || o.value ? `${e.leave || ""} ${o.value || ""}` : void 0
  );
  return { originClassRef: o, enterActiveClassRef: i, leaveActiveClassRef: t };
}
function Q(e, r, ...o) {
  if (e in r) {
    const t = r[e];
    return typeof t == "function" ? t(...o) : t;
  }
  const i = new Error(
    `Tried to handle "${e}" but there is no handler defined. Only defined handlers are: ${Object.keys(
      r
    ).map((t) => `"${t}"`).join(", ")}.`
  );
  throw Error.captureStackTrace && Error.captureStackTrace(i, Q), i;
}
const _ = [
  "[contentEditable=true]",
  "[tabindex]",
  "a[href]",
  "area[href]",
  "button:not([disabled])",
  "iframe",
  "input:not([disabled])",
  "select:not([disabled])",
  "textarea:not([disabled])"
].map(
  // TODO: Remove this once JSDOM fixes the issue where an element that is
  // "hidden" can be the document.activeElement, because this is not possible
  // in real browsers.
  process.env.NODE_ENV === "test" ? (e) => `${e}:not([tabindex='-1']):not([style*='display: none'])` : (e) => `${e}:not([tabindex='-1'])`
).join(",");
var Z = /* @__PURE__ */ ((e) => (e[e.Strict = 0] = "Strict", e[e.Loose = 1] = "Loose", e))(Z || {});
function $e(e, r = 0) {
  var o;
  return e === ((o = K(e)) == null ? void 0 : o.body) ? !1 : Q(r, {
    [
      0
      /* Strict */
    ]() {
      return e.matches(_);
    },
    [
      1
      /* Loose */
    ]() {
      let i = e;
      for (; i !== null; ) {
        if (i.matches(_))
          return !0;
        i = i.parentElement;
      }
      return !1;
    }
  });
}
function F(e, r, o) {
  z.isServer || J((i) => {
    document.addEventListener(e, r, o), i(() => document.removeEventListener(e, r, o));
  });
}
function Ve(e, r, o = T(() => !0)) {
  function i(a, c) {
    if (!o.value || a.defaultPrevented)
      return;
    const s = c(a);
    if (s === null || !s.getRootNode().contains(s))
      return;
    const u = function d(f) {
      return typeof f == "function" ? d(f()) : Array.isArray(f) || f instanceof Set ? f : [f];
    }(e);
    for (const d of u) {
      if (d === null)
        continue;
      const f = d instanceof HTMLElement ? d : j(d);
      if (f != null && f.contains(s) || a.composed && a.composedPath().includes(f))
        return;
    }
    return (
      // This check alllows us to know whether or not we clicked on a "focusable" element like a
      // button or an input. This is a backwards compatibility check so that you can open a <Menu
      // /> and click on another <Menu /> which should close Menu A and open Menu B. We might
      // revisit that so that you will require 2 clicks instead.
      !$e(s, Z.Loose) && // This could be improved, but the `Combobox.Button` adds tabIndex={-1} to make it
      // unfocusable via the keyboard so that tabbing to the next item from the input doesn't
      // first go to the button.
      s.tabIndex !== -1 && a.preventDefault(), r(a, s)
    );
  }
  const t = g(null);
  F("mousedown", (a) => {
    var c, s;
    o.value && (t.value = ((s = (c = a.composedPath) == null ? void 0 : c.call(a)) == null ? void 0 : s[0]) || a.target);
  }, !0), F(
    "click",
    (a) => {
      t.value && (i(a, () => t.value), t.value = null);
    },
    // We will use the `capture` phase so that layers in between with `event.stopPropagation()`
    // don't "cancel" this outside click check. E.g.: A `Menu` inside a `DialogPanel` if the `Menu`
    // is open, and you click outside of it in the `DialogPanel` the `Menu` should close. However,
    // the `DialogPanel` has a `onClick(e) { e.stopPropagation() }` which would cancel this.
    !0
  ), F("blur", (a) => i(
    a,
    () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null
  ), !0);
}
const ee = Symbol("ReferenceContext"), te = Symbol("FloatingContext"), ne = Symbol("ArrowContext");
function re(e) {
  const r = k(ee, null);
  if (r === null) {
    const o = new Error(`<${e} /> must be in the <Float /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(o, re), o;
  }
  return r;
}
function oe(e) {
  const r = k(te, null);
  if (r === null) {
    const o = new Error(`<${e} /> must be in the <Float /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(o, oe), o;
  }
  return r;
}
function ae(e) {
  const r = k(ne, null);
  if (r === null) {
    const o = new Error(`<${e} /> must be in the <Float /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(o, ae), o;
  }
  return r;
}
const n = {
  as: {
    type: [String, Function],
    default: "template"
  },
  floatingAs: {
    type: [String, Function],
    default: "div"
  },
  show: {
    type: Boolean,
    default: null
  },
  placement: {
    type: String,
    default: "bottom-start"
  },
  strategy: {
    type: String,
    default: "absolute"
  },
  offset: [Number, Function, Object],
  shift: {
    type: [Boolean, Number, Object],
    default: !1
  },
  flip: {
    type: [Boolean, Number, Object],
    default: !1
  },
  arrow: {
    type: [Boolean, Number],
    default: !1
  },
  autoPlacement: {
    type: [Boolean, Object],
    default: !1
  },
  hide: {
    type: [Boolean, Object],
    default: !1
  },
  autoUpdate: {
    type: [Boolean, Object],
    default: !0
  },
  zIndex: {
    type: [Number, String],
    default: 9999
  },
  transitionName: String,
  transitionType: String,
  enter: String,
  enterFrom: String,
  enterTo: String,
  leave: String,
  leaveFrom: String,
  leaveTo: String,
  originClass: [String, Function],
  tailwindcssOriginClass: {
    type: Boolean,
    default: !1
  },
  portal: {
    type: Boolean,
    default: !1
  },
  transform: {
    type: Boolean,
    default: !0
  },
  adaptiveWidth: {
    type: Boolean,
    default: !1
  },
  composable: {
    type: Boolean,
    default: !1
  },
  dialog: {
    type: Boolean,
    default: !1
  },
  middleware: {
    type: [Array, Function],
    default: () => []
  }
};
function ie(e, r, o, i) {
  const { referenceRef: t } = i, a = r, c = N(o, {
    ref: t
  }), s = M(
    e,
    a.as === "template" ? c : {}
  );
  return a.as === "template" ? s : typeof a.as == "string" ? p(a.as, c, [s]) : p(a.as, c, () => [s]);
}
function L(e, r, o, i) {
  const { floatingRef: t, props: a, mounted: c, show: s, x: u, y: d, placement: f, strategy: h, referenceElWidth: m, updateFloating: y } = i, l = N(
    { ...a, as: a.floatingAs },
    r
  ), { enterActiveClassRef: v, leaveActiveClassRef: C } = je(l, f), E = {
    enterActiveClass: v.value,
    enterFromClass: l.enterFrom,
    enterToClass: l.enterTo,
    leaveActiveClass: C.value,
    leaveFromClass: l.leaveFrom,
    leaveToClass: l.leaveTo
  }, x = {
    name: l.transitionName,
    type: l.transitionType,
    appear: !0,
    ...l.transitionName ? {} : E,
    onBeforeEnter() {
      s.value = !0;
    },
    onAfterLeave() {
      s.value = !1;
    }
  }, R = {
    enter: v.value,
    enterFrom: l.enterFrom,
    enterTo: l.enterTo,
    leave: C.value,
    leaveFrom: l.leaveFrom,
    leaveTo: l.leaveTo,
    onBeforeEnter: x.onBeforeEnter,
    onAfterLeave: x.onAfterLeave
  }, $ = {
    style: {
      // If enable dialog mode, then set `transform` to false.
      ...!l.dialog && l.transform ? {
        position: h.value,
        zIndex: l.zIndex,
        top: "0px",
        left: "0px",
        right: "auto",
        bottom: "auto",
        transform: `translate(${Math.round(u.value || 0)}px,${Math.round(d.value || 0)}px)`
      } : {
        position: h.value,
        zIndex: l.zIndex,
        top: `${d.value || 0}px`,
        left: `${u.value || 0}px`
      },
      width: l.adaptiveWidth && typeof m.value == "number" ? `${m.value}px` : void 0
    }
  };
  function V(w) {
    return l.portal ? p(we, () => w) : w;
  }
  function P(w) {
    const A = N(
      $,
      o,
      l.dialog ? {} : { ref: t }
    );
    return l.as === "template" ? w : typeof l.as == "string" ? p(l.as, A, w) : p(l.as, A, () => w);
  }
  function B() {
    function w() {
      var b;
      const A = l.as === "template" ? N(
        $,
        o,
        l.dialog ? {} : { ref: t }
      ) : null, S = M(e, A);
      return ((b = S.props) == null ? void 0 : b.unmount) === !1 ? (y(), S) : typeof l.show != "boolean" || l.show ? S : Y();
    }
    return z.isServer ? c.value && l.show ? w() : Y() : l.transitionChild ? p(be, {
      key: `placement-${f.value}`,
      ...l.dialog ? { ref: t } : {},
      as: "template",
      ...R
    }, w) : p(ye, {
      ...l.dialog ? { ref: t } : {},
      ...x
    }, w);
  }
  return V(
    P(
      B()
    )
  );
}
function le(e, r, o, i, t) {
  const a = g(!1), c = X(i, "placement"), s = X(i, "strategy"), u = ge({}), d = g(null), f = g(void 0), h = g(void 0), m = T(() => j(r)), y = T(() => j(o)), l = T(
    () => W(m) && W(y)
  ), { x: v, y: C, placement: E, strategy: x, middlewareData: R, update: $ } = Ce(m, y, {
    placement: c,
    strategy: s,
    middleware: u,
    whileElementsMounted: () => {
    }
  }), V = g(null);
  G(() => {
    a.value = !0;
  });
  function P() {
    l.value && ($(), t("update"));
  }
  O([c, s, u], P, { flush: "sync" }), Ne(
    u,
    m,
    y,
    d,
    i
  ), O(R, () => {
    const b = R.value.arrow;
    f.value = b == null ? void 0 : b.x, h.value = b == null ? void 0 : b.y;
  }), Re(i.adaptiveWidth, m, V), O(e, async (b, He, ue) => {
    if (await pe(), e.value && l.value && i.autoUpdate) {
      const fe = Se(
        m.value,
        y.value,
        P,
        typeof i.autoUpdate == "object" ? i.autoUpdate : void 0
      );
      t("show"), ue(() => {
        fe(), e.value || t("hide");
      });
    }
  }, { flush: "post", immediate: !0 });
  const B = g(!0);
  O(m, () => {
    !(m.value instanceof Element) && l.value && B.value && (B.value = !1, window.requestAnimationFrame(() => {
      B.value = !0, P();
    }));
  }, { flush: "sync" });
  const w = {
    referenceRef: r,
    placement: E
  }, A = {
    floatingRef: o,
    props: i,
    mounted: a,
    show: e,
    x: v,
    y: C,
    placement: E,
    strategy: x,
    referenceElWidth: V,
    updateFloating: P
  }, S = {
    ref: d,
    placement: E,
    x: f,
    y: h
  };
  return U(ne, S), { referenceApi: w, floatingApi: A, arrowApi: S, x: v, y: C, placement: E, strategy: x, referenceEl: m, floatingEl: y, middlewareData: R, update: P };
}
const Ie = {
  name: "Float",
  inheritAttrs: !1,
  props: n,
  emits: ["show", "hide", "update"],
  setup(e, { emit: r, slots: o, attrs: i }) {
    const t = g(e.show ?? !1), a = g(null), c = g(null), {
      referenceApi: s,
      floatingApi: u,
      placement: d
    } = le(t, a, c, e, r);
    function f(m) {
      return e.as === "template" ? m : typeof e.as == "string" ? p(e.as, i, m) : p(e.as, i, () => m);
    }
    const h = {
      placement: d.value
    };
    return e.composable || e.dialog ? (U(ee, s), U(te, u), () => {
      if (o.default)
        return f(o.default(h));
    }) : () => {
      if (!o.default)
        return;
      const [m, y] = D(o.default(h)).filter(I);
      if (!I(m))
        return;
      const l = ie(
        m,
        { as: "template" },
        {},
        s
      ), v = L(
        y,
        { as: e.floatingAs },
        {},
        u
      );
      return f([
        l,
        v
      ]);
    };
  }
}, ze = {
  as: n.as
}, Je = {
  name: "FloatReference",
  inheritAttrs: !1,
  props: ze,
  setup(e, { slots: r, attrs: o }) {
    const i = re("FloatReference"), { placement: t } = i;
    return () => {
      if (!r.default)
        return;
      const a = {
        placement: t.value
      };
      return ie(
        r.default(a)[0],
        e,
        o,
        i
      );
    };
  }
}, q = {
  as: n.floatingAs,
  transitionName: n.transitionName,
  transitionType: n.transitionType,
  enter: n.enter,
  enterFrom: n.enterFrom,
  enterTo: n.enterTo,
  leave: n.leave,
  leaveFrom: n.leaveFrom,
  leaveTo: n.leaveTo,
  originClass: n.originClass,
  tailwindcssOriginClass: n.tailwindcssOriginClass,
  transitionChild: {
    type: Boolean,
    default: !1
  }
}, Ke = {
  name: "FloatContent",
  inheritAttrs: !1,
  props: q,
  setup(e, { slots: r, attrs: o }) {
    const i = oe("FloatContent"), { placement: t } = i;
    return () => {
      if (!r.default)
        return;
      const a = {
        placement: t.value
      }, c = Object.entries(e).reduce((s, [u, d]) => {
        const f = q;
        return (typeof f[u] == "object" && d === f[u].default || d === void 0) && delete s[u], s;
      }, { ...e });
      return L(
        r.default(a)[0],
        c,
        o,
        i
      );
    };
  }
}, Ue = {
  as: {
    ...n.as,
    default: "div"
  },
  offset: {
    type: Number,
    default: 4
  }
}, Qe = {
  name: "FloatArrow",
  props: Ue,
  setup(e, { slots: r, attrs: o }) {
    const { ref: i, placement: t, x: a, y: c } = ae("FloatArrow");
    return () => {
      var d;
      const s = {
        top: "bottom",
        right: "left",
        bottom: "top",
        left: "right"
      }[t.value.split("-")[0]], u = {
        left: typeof a.value == "number" ? `${a.value}px` : void 0,
        top: typeof c.value == "number" ? `${c.value}px` : void 0,
        right: void 0,
        bottom: void 0,
        [s]: `${e.offset * -1}px`
      };
      if (e.as === "template") {
        const f = {
          placement: t.value
        }, h = (d = r.default) == null ? void 0 : d.call(r, f)[0];
        return !h || !I(h) ? void 0 : M(h, { ref: i, style: u });
      }
      return p(e.as, N(o, { ref: i, style: u }));
    };
  }
}, Me = {
  as: n.as,
  show: n.show,
  placement: n.placement,
  strategy: n.strategy,
  offset: n.offset,
  shift: n.shift,
  flip: n.flip,
  arrow: n.arrow,
  autoPlacement: n.autoPlacement,
  hide: n.hide,
  autoUpdate: n.autoUpdate,
  zIndex: n.zIndex,
  transitionName: n.transitionName,
  transitionType: n.transitionType,
  enter: n.enter,
  enterFrom: n.enterFrom,
  enterTo: n.enterTo,
  leave: n.leave,
  leaveFrom: n.leaveFrom,
  leaveTo: n.leaveTo,
  originClass: n.originClass,
  tailwindcssOriginClass: n.tailwindcssOriginClass,
  portal: n.portal,
  transform: n.transform,
  middleware: n.middleware
}, se = {
  name: "FloatVirtual",
  inheritAttrs: !1,
  props: Me,
  emits: ["initial", "show", "hide", "update"],
  setup(e, { emit: r, slots: o, attrs: i }) {
    const t = g(e.show ?? !1), a = g({
      getBoundingClientRect() {
        return {
          x: 0,
          y: 0,
          top: 0,
          left: 0,
          bottom: 0,
          right: 0,
          width: 0,
          height: 0
        };
      }
    }), c = g(null), {
      floatingApi: s,
      placement: u
    } = le(t, a, c, e, r);
    O(() => e.show, () => {
      t.value = e.show ?? !1;
    });
    function d() {
      t.value = !1;
    }
    return r("initial", {
      show: t,
      placement: u,
      reference: a,
      floating: c
    }), () => {
      if (!o.default)
        return;
      const f = {
        placement: u.value,
        close: d
      }, [h] = D(o.default(f)).filter(I);
      return L(
        h,
        {
          as: e.as,
          show: t.value
        },
        i,
        s
      );
    };
  }
}, ke = {
  as: n.as,
  placement: n.placement,
  strategy: n.strategy,
  offset: n.offset,
  shift: n.shift,
  flip: {
    ...n.flip,
    default: !0
  },
  arrow: n.arrow,
  autoPlacement: n.autoPlacement,
  hide: n.hide,
  autoUpdate: n.autoUpdate,
  zIndex: n.zIndex,
  transitionName: n.transitionName,
  transitionType: n.transitionType,
  enter: n.enter,
  enterFrom: n.enterFrom,
  enterTo: n.enterTo,
  leave: n.leave,
  leaveFrom: n.leaveFrom,
  leaveTo: n.leaveTo,
  originClass: n.originClass,
  tailwindcssOriginClass: n.tailwindcssOriginClass,
  transform: n.transform,
  middleware: n.middleware
}, Ze = {
  name: "FloatContextMenu",
  inheritAttrs: !1,
  props: ke,
  emits: ["show", "hide", "update"],
  setup(e, { emit: r, slots: o, attrs: i }) {
    function t({ show: a, reference: c, floating: s }) {
      F("contextmenu", (u) => {
        u.preventDefault(), c.value = {
          getBoundingClientRect() {
            return {
              width: 0,
              height: 0,
              x: u.clientX,
              y: u.clientY,
              top: u.clientY,
              left: u.clientX,
              right: u.clientX,
              bottom: u.clientY
            };
          }
        }, a.value = !0;
      }), Ve(s, () => {
        a.value = !1;
      }, T(() => a.value));
    }
    return () => {
      if (o.default)
        return p(se, {
          ...e,
          ...i,
          portal: !0,
          onInitial: t,
          onShow: () => r("show"),
          onHide: () => r("hide"),
          onUpdate: () => r("update")
        }, o.default);
    };
  }
}, De = {
  as: n.as,
  placement: n.placement,
  strategy: n.strategy,
  offset: n.offset,
  shift: n.shift,
  flip: n.flip,
  arrow: n.arrow,
  autoPlacement: n.autoPlacement,
  hide: n.hide,
  autoUpdate: n.autoUpdate,
  zIndex: n.zIndex,
  transitionName: n.transitionName,
  transitionType: n.transitionType,
  enter: n.enter,
  enterFrom: n.enterFrom,
  enterTo: n.enterTo,
  leave: n.leave,
  leaveFrom: n.leaveFrom,
  leaveTo: n.leaveTo,
  originClass: n.originClass,
  tailwindcssOriginClass: n.tailwindcssOriginClass,
  transform: n.transform,
  middleware: n.middleware,
  globalHideCursor: {
    type: Boolean,
    default: !0
  }
}, et = {
  name: "FloatCursor",
  inheritAttrs: !1,
  props: De,
  emits: ["show", "hide", "update"],
  setup({ globalHideCursor: e, ...r }, { emit: o, slots: i, attrs: t }) {
    function a({ show: c, reference: s, floating: u }) {
      function d() {
        c.value = !0;
      }
      function f() {
        c.value = !1;
      }
      function h(v) {
        s.value = {
          getBoundingClientRect() {
            return {
              width: 0,
              height: 0,
              x: v.clientX,
              y: v.clientY,
              top: v.clientY,
              left: v.clientX,
              right: v.clientX,
              bottom: v.clientY
            };
          }
        };
      }
      function m(v) {
        d(), h(v);
      }
      function y(v) {
        d(), h(v.touches[0]);
      }
      const l = K(u);
      l && (J((v) => {
        if (e && !l.getElementById("headlesui-float-cursor-style")) {
          const C = l.createElement("style");
          (l.head || l.getElementsByTagName("head")[0]).appendChild(C), C.id = "headlesui-float-cursor-style", C.appendChild(l.createTextNode([
            "*, *::before, *::after {",
            "  cursor: none !important;",
            "}",
            ".headlesui-float-cursor-root {",
            "  pointer-events: none !important;",
            "}"
          ].join(`
`))), v(() => {
            var x;
            return (x = l.getElementById("headlesui-float-cursor-style")) == null ? void 0 : x.remove();
          });
        }
      }, { flush: "post" }), "ontouchstart" in window || navigator.maxTouchPoints > 0 ? (F("touchstart", y), F("touchend", f), F("touchmove", y)) : (F("mouseenter", m), F("mouseleave", f), F("mousemove", m)));
    }
    return () => {
      if (i.default)
        return p(se, {
          ...r,
          ...t,
          portal: !0,
          class: "headlesui-float-cursor-root",
          onInitial: a,
          onShow: () => o("show"),
          onHide: () => o("hide"),
          onUpdate: () => o("update")
        }, i.default);
    };
  }
};
function tt(e) {
  return (r, { slots: o }) => p(Ie, N(
    e,
    r
  ), o);
}
const Le = [
  "Float",
  "FloatArrow"
];
function nt(e = {}) {
  const { prefix: r = "" } = e;
  return {
    type: "component",
    resolve: (o) => {
      if (o.startsWith(r)) {
        const i = o.substring(r.length);
        if (Le.includes(i))
          return {
            name: i,
            from: "@headlessui-float/vue"
          };
      }
    }
  };
}
export {
  Ie as Float,
  Qe as FloatArrow,
  Ue as FloatArrowPropsValidators,
  Ke as FloatContent,
  q as FloatContentPropsValidators,
  Ze as FloatContextMenu,
  ke as FloatContextMenuPropsValidators,
  et as FloatCursor,
  De as FloatCursorPropsValidators,
  n as FloatPropsValidators,
  Je as FloatReference,
  ze as FloatReferencePropsValidators,
  se as FloatVirtual,
  Me as FloatVirtualPropsValidators,
  nt as HeadlessUiFloatResolver,
  tt as createHighOrderFloatComponent,
  L as renderFloatingElement,
  ie as renderReferenceElement,
  Be as tailwindcssOriginClassResolver,
  Ge as tailwindcssOriginSafelist,
  le as useFloat,
  Ve as useOutsideClick
};
